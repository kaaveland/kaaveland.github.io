<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Advent of Code on Robin's blog</title><link>https://kaveland.no/tags/advent-of-code/</link><description>Recent content in Advent of Code on Robin's blog</description><generator>Hugo -- 0.145.0</generator><language>en-us</language><lastBuildDate>Mon, 10 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://kaveland.no/tags/advent-of-code/index.xml" rel="self" type="application/rss+xml"/><item><title>Constraint propagation: Mutual recursion for fun and profit</title><link>https://kaveland.no/posts/2025-03-10-mutual-recursion-for-fun-and-profit/</link><pubDate>Mon, 10 Mar 2025 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2025-03-10-mutual-recursion-for-fun-and-profit/</guid><description>&lt;p>I&amp;rsquo;ve been wanting to write this post for a while, about what I think is an
elegant way to solve some &lt;a href="https://en.wikipedia.org/wiki/Constraint_satisfaction_problem">constraint satisfaction
problems&lt;/a>. Constraints
tend to come up fairly often in real world programs, and some times it can be
effective to treat them as constraint satisfaction problems. This post has a bit
of background on constraint satisfaction problems I&amp;rsquo;ve encountered recently,
then it goes over to develop Rust code for an algorithm that we can easily use
to solve some Advent of Code problems, and we use it to make a solver for
&lt;a href="https://en.wikipedia.org/wiki/Sudoku">sudoku&lt;/a> puzzles. Along the way, we
explain the syntax we use, it shouldn&amp;rsquo;t be too hard to understand for someone
who is unfamiliar with the language.&lt;/p></description></item></channel></rss>