<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Postgres on Robin's blog</title><link>https://kaveland.no/tags/postgres/</link><description>Recent content in Postgres on Robin's blog</description><generator>Hugo -- 0.145.0</generator><language>en-us</language><lastBuildDate>Wed, 30 Apr 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://kaveland.no/tags/postgres/index.xml" rel="self" type="application/rss+xml"/><item><title>That join sure is a natural</title><link>https://kaveland.no/posts/2025-04-30-that-join-is-natural/</link><pubDate>Wed, 30 Apr 2025 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2025-04-30-that-join-is-natural/</guid><description>&lt;p>Working with SQL can sometimes be painful, &lt;em>especially&lt;/em> when you have composite keys and many tables to join. Today I want to write a helpful tip for designing data models with such keys, to make it less painful to handwrite SQL for them.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>&lt;em>TIP:&lt;/em>&lt;/strong> Introduce a consistent naming standard for all columns that take part in a primary key, so that the column has the same name in all tables it is used, also where it&amp;rsquo;s on the referencing side of a foreign key.&lt;/p></description></item><item><title>Checking SQL migrations with eugene</title><link>https://kaveland.no/posts/2025-04-16-whats-up-eugene/</link><pubDate>Wed, 16 Apr 2025 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2025-04-16-whats-up-eugene/</guid><description>&lt;p>It’s been almost a year since I last posted an update on &lt;a href="https://github.com/kaaveland/eugene/">eugene&lt;/a>, the CLI tool I’m building to help people write safer SQL migration scripts for postgres. I announced this tool in &lt;a href="https://kaveland.no/posts/2024-05-06-careful-with-that-lock-eugene-pt-2">Careful with That Lock, Eugene: Part 2&lt;/a>. At the time, &lt;code>eugene&lt;/code> would execute a single SQL script, recording all the locks acquired and warn about possible downtime due to migrations.&lt;/p>
&lt;p>It could produce JSON suitable for automated tooling and Markdown suitable for human reading and using in CI comments/checks. That version was already good enough for me to start using in real projects — but it&amp;rsquo;s improved a lot since then, it&amp;rsquo;s now easy to run with almost no setup.&lt;/p></description></item><item><title>Finding foreign keys missing indexes</title><link>https://kaveland.no/posts/2025-04-04-finding-missing-indexes-in-pg-catalog/</link><pubDate>Fri, 04 Apr 2025 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2025-04-04-finding-missing-indexes-in-pg-catalog/</guid><description>&lt;p>Last week I was made aware that we had some foreign keys not backed by indexes in the system we&amp;rsquo;re developing at work. Foreign keys in postgres must be backed by an index only on the side they refer &lt;em>to&lt;/em>, not necessarily the side they refer &lt;em>from&lt;/em>. Here&amp;rsquo;s an example:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">create&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">author&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">bigint&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">generated&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">always&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">identity&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">primary&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">text&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">not&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">create&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">book&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">bigint&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">generated&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">always&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">as&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">identity&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">primary&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">key&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">author&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">bigint&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">not&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">null&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">references&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">author&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">text&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">not&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">null&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this example, there&amp;rsquo;s a foreign key from the &lt;code>book&lt;/code> table to the &lt;code>author&lt;/code> table. Since &lt;code>author&lt;/code> refers to a primary key in the &lt;code>author&lt;/code> table, inserts into &lt;code>book&lt;/code> can validate very quickly. There&amp;rsquo;s no index on the &lt;code>author&lt;/code> column in the &lt;code>book&lt;/code> table though. The consequence of this is that &lt;code>delete&lt;/code> on &lt;code>author&lt;/code> must check every single row in &lt;code>book&lt;/code> to check if it&amp;rsquo;s safe to actually delete. The really annoying part of this is that the scan does not show up in query plans:&lt;/p></description></item><item><title>Why would I use DuckDB for that?</title><link>https://kaveland.no/posts/2025-03-02-can-i-just-use-postgres/</link><pubDate>Sun, 02 Mar 2025 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2025-03-02-can-i-just-use-postgres/</guid><description>&lt;p>The past few weeks I&amp;rsquo;ve been experimenting with &lt;a href="https://duckdb.org/">DuckDB&lt;/a>, and as a consequence I&amp;rsquo;ve ended up talking about it a lot as well. I&amp;rsquo;m not going to lie, I really like it! However, experienced programmers will rightly be skeptical to add new technology that overlaps with something that already works great. So why not just use postgres?&lt;/p>
&lt;p>Well, I really like postgres too, and I think you should consider just using it! But despite both of these technologies being all about tabular data, they&amp;rsquo;re not really for the same kinds of problems. I think DuckDB is primarily an analysis or ELT tool, and it really excels in this space. postgres &lt;em>can&lt;/em> do a lot of the things that DuckDB can do, but not nearly as fast or easily. I wouldn&amp;rsquo;t want to use DuckDB for a transactional workload, so it&amp;rsquo;s not going to replace postgres for anything that I use it for.&lt;/p></description></item><item><title>Exploring a webapp using psql and pg_stat_statements</title><link>https://kaveland.no/posts/2025-01-06-exploring-a-webapp-using-pg-stat/</link><pubDate>Mon, 06 Jan 2025 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2025-01-06-exploring-a-webapp-using-pg-stat/</guid><description>&lt;p>It&amp;rsquo;s always an exciting day for me when I get access to the source
code for an entirely new application I need to work on. How does it
look inside, how does it work? Sometimes, there&amp;rsquo;s some design
documentation along with it, or operational procedures, or maybe some
developer handbook in a wiki. I do check all of those, but I don&amp;rsquo;t
expect any of those things to accurately describe how the code works,
because they tend to change less frequently. It&amp;rsquo;s also fairly
low-bandwidth, it takes a ton of time to ingest technical text.&lt;/p></description></item><item><title>Consider using array operators over the SQL in operator</title><link>https://kaveland.no/posts/2024-09-21-equals-any-over-where-in/</link><pubDate>Sat, 21 Sep 2024 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2024-09-21-equals-any-over-where-in/</guid><description>&lt;p>In my post about &lt;a href="https://kaveland.no/posts/2024-08-30-multi-selecting-by-composite-key/">batch operations&lt;/a>, I used the
&lt;code>where id = any(:ids)&lt;/code> pattern, with &lt;code>ids&lt;/code> bound to a JDBC array. I&amp;rsquo;ve gotten questions about that
afterwards, asking why I do it like that, instead of using &lt;code>in (:id1, :id2, ...)&lt;/code>. Many libraries
can take care of the dynamic SQL generation for you, so often you can just write &lt;code>in (:ids)&lt;/code>, just
like the array example. I would still prefer to use the &lt;code>= any(:ids)&lt;/code> pattern, and I decided to write
down my reasoning here.&lt;/p></description></item><item><title>Batch operations using composite keys in postgres over jdbc</title><link>https://kaveland.no/posts/2024-08-30-multi-selecting-by-composite-key/</link><pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2024-08-30-multi-selecting-by-composite-key/</guid><description>&lt;p>Throughout a career as a software developer, you encounter many patterns. Some appear just often
enough to remember that they exist, but you still need to look them up every time. I&amp;rsquo;ve discovered
that writing things down helps me remember them more easily. This particular pattern is very useful
for my current project. So, it&amp;rsquo;s time to write it down and hopefully commit it to memory properly
this time. Although this post is specific to PostgreSQL, I&amp;rsquo;m sure other databases have the necessary
features to achieve the same results efficiently.&lt;/p></description></item><item><title>Using short lived postgres servers for testing</title><link>https://kaveland.no/posts/2024-05-27-shortlived-postgres-servers/</link><pubDate>Mon, 27 May 2024 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2024-05-27-shortlived-postgres-servers/</guid><description>&lt;p>Database servers are usually long-lived, and important parts of the infrastructure
that we build on. We rarely set them up from scratch, because we have to take
such good care of them over time. I think this causes a lot of people to think
that setting up a database server is some mysteriously difficult ordeal. To be clear,
that&amp;rsquo;s actually true, if you need high availability and a solid recovery point objective.
But there are a lot of use cases where that&amp;rsquo;s overkill, for example short-lived
test environments, or CI/CD pipelines.&lt;/p></description></item><item><title>Linting postgres migration scripts</title><link>https://kaveland.no/posts/2024-05-16-linting-postgres-migration-scripts/</link><pubDate>Thu, 16 May 2024 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2024-05-16-linting-postgres-migration-scripts/</guid><description>&lt;p>I have been working quite a bit on picking up dangerous migration patterns in
migration scripts over at the &lt;a href="https://github.com/kaaveland/eugene">eugene repository&lt;/a>
lately. A major feature I&amp;rsquo;ve added is syntax tree analysis, so that we can pick
up some patterns without having to run the SQL scripts. This isn&amp;rsquo;t quite as precise
as running the scripts, but it&amp;rsquo;s a lot faster and can catch quite a few
common mistakes. So let&amp;rsquo;s take a look at how it works!&lt;/p></description></item><item><title>Careful with That Lock, Eugene: Part 2</title><link>https://kaveland.no/posts/2024-05-06-careful-with-that-lock-eugene-pt-2/</link><pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2024-05-06-careful-with-that-lock-eugene-pt-2/</guid><description>&lt;p>A while back, I wrote
&lt;a href="https://kaveland.no/posts/2024-04-12-careful-with-that-lock-eugene">Careful with That Lock, Eugene&lt;/a> about an
idea for how to check if a database migration is likely to disturb production.
That post came about after having an inspiring chat with a colleague about
the advantages of transactional migration scripts and the ability to check
the postgres system catalog views before committing a transaction.&lt;/p>
&lt;p>Over the past few weeks, I&amp;rsquo;ve been experimenting with this idea to test if I can
use it to build valuable safety checks for DDL migrations. Kind of like
&lt;a href="https://www.shellcheck.net/">shellcheck&lt;/a>, but for database DDL migrations.&lt;/p></description></item><item><title>Careful with That Lock, Eugene</title><link>https://kaveland.no/posts/2024-04-12-careful-with-that-lock-eugene/</link><pubDate>Fri, 12 Apr 2024 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2024-04-12-careful-with-that-lock-eugene/</guid><description>&lt;p>It is rewarding to work on software that people care about and use all around
the clock. This constant usage means we can&amp;rsquo;t simply take the system offline for
maintenance without upsetting users. Therefore, techniques that allow us to
update the software seamlessly without downtime or compromising service
quality are incredibly valuable.&lt;/p>
&lt;p>Most projects I&amp;rsquo;ve worked on use a relational database for persistence, and have
some sort of migration tool like flyway or liquibase to make changes to the
database schema. This post is about a particular kind of migration situation
that, in my experience, most developers who work on such projects will encounter
at some point in their career. They will want to apply a simple, and seemingly
innocent migration, like adding a column to a table and it&amp;rsquo;ll cause some number
of requests to fail, or maybe even a small outage. There are some tricks we can
use here to reduce risk and automatically detect some patterns that cause this
problem.&lt;/p></description></item><item><title>How to test for missing indexes on foreign keys</title><link>https://kaveland.no/posts/2024-04-04-testcase-for-foreign-keys/</link><pubDate>Thu, 04 Apr 2024 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2024-04-04-testcase-for-foreign-keys/</guid><description>&lt;p>If you&amp;rsquo;re developing a transactional application backed by postgres, there&amp;rsquo;s a
pretty cool trick you can use to check if you&amp;rsquo;re missing indexes that could
potentially cause serious performance issues or even outages. In particular, I
mean foreign keys where the referencing side of the constraint does not have an
index. The idea is very simple, we can select all of the columns that take part
in a foreign key, then remove the ones that take part in a complete index, and
the remainder should be the empty set, or possibly match a known allowlist. I
think this is a valuable addition to the test cases for your database
migrations, or if you can&amp;rsquo;t easily do that, maybe in your CI/CD pipeline.&lt;/p></description></item><item><title>Isolating integration tests that commit transactions</title><link>https://kaveland.no/posts/2024-03-10-testing-transactions-that-commit/</link><pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2024-03-10-testing-transactions-that-commit/</guid><description>&lt;p>For tests that need to touch the database, it is generally a really good idea to
roll back transactions. That way, you can run lots of tests in parallell or in
any arbitrary order and the tests won&amp;rsquo;t interfere with each other. But
sometimes, that just isn&amp;rsquo;t possible. One reason for this could be that the code
base handles transactions in a way that makes it really hard to get a handle on
them in the right place, or it could be a legacy code base where everything is
running with auto-commit or some other explanation. Either way, it is very
important to be able to isolate effectful tests from each other both to get good
performance out of building on multi-core machines and to avoid flaky tests or
tests that break when they run in a different order.&lt;/p></description></item><item><title>Protecting your postgres server from your application</title><link>https://kaveland.no/posts/2023-05-09-configure-postgres/</link><pubDate>Tue, 09 May 2023 00:00:00 +0000</pubDate><guid>https://kaveland.no/posts/2023-05-09-configure-postgres/</guid><description>&lt;p>There are 2 configuration options that every OLTP application that uses postgres
should set, in order to protect the database from high load:&lt;/p>
&lt;ul>
&lt;li>&lt;code>statement_timeout&lt;/code>&lt;/li>
&lt;li>&lt;code>idle_in_transaction_session_timeout&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>These can both be set by client configuration and require no special
permissions to set, and are easily overridden locally for transactions that have
different requirements.&lt;/p>
&lt;p>They can be a bit scary to retrofit to existing applications, but we can
activate two postgres extensions to help us measure our queries to find safe
values to set:&lt;/p></description></item></channel></rss>