<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Constraint propagation: Mutual recursion for fun and profit | Robin's blog</title>
<meta name=keywords content="rust,advent of code,algorithms"><meta name=description content="I&rsquo;ve been wanting to write this post for a while, about what I think is an
elegant way to solve some constraint satisfaction
problems. Constraints
tend to come up fairly often in real world programs, and some times it can be
effective to treat them as constraint satisfaction problems. This post has a bit
of background on constraint satisfaction problems I&rsquo;ve encountered recently,
then it goes over to develop Rust code for an algorithm that we can easily use
to solve some Advent of Code problems, and we use it to make a solver for
sudoku puzzles. Along the way, we
explain the syntax we use, it shouldn&rsquo;t be too hard to understand for someone
who is unfamiliar with the language."><meta name=author content="Robin Kåveland"><link rel=canonical href=https://kaveland.no/posts/2025-03-10-mutual-recursion-for-fun-and-profit/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://kaveland.no/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kaveland.no/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kaveland.no/favicon-32x32.png><link rel=apple-touch-icon href=https://kaveland.no/apple-touch-icon.png><link rel=mask-icon href=https://kaveland.no/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kaveland.no/posts/2025-03-10-mutual-recursion-for-fun-and-profit/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer data-domain=kaveland.no src=https://plausible.io/js/script.js></script><meta property="og:title" content="Constraint propagation: Mutual recursion for fun and profit"><meta property="og:description" content="I&rsquo;ve been wanting to write this post for a while, about what I think is an
elegant way to solve some constraint satisfaction
problems. Constraints
tend to come up fairly often in real world programs, and some times it can be
effective to treat them as constraint satisfaction problems. This post has a bit
of background on constraint satisfaction problems I&rsquo;ve encountered recently,
then it goes over to develop Rust code for an algorithm that we can easily use
to solve some Advent of Code problems, and we use it to make a solver for
sudoku puzzles. Along the way, we
explain the syntax we use, it shouldn&rsquo;t be too hard to understand for someone
who is unfamiliar with the language."><meta property="og:type" content="article"><meta property="og:url" content="https://kaveland.no/posts/2025-03-10-mutual-recursion-for-fun-and-profit/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-10T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-10T00:00:00+00:00"><meta property="og:site_name" content="Robin's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Constraint propagation: Mutual recursion for fun and profit"><meta name=twitter:description content="I&rsquo;ve been wanting to write this post for a while, about what I think is an
elegant way to solve some constraint satisfaction
problems. Constraints
tend to come up fairly often in real world programs, and some times it can be
effective to treat them as constraint satisfaction problems. This post has a bit
of background on constraint satisfaction problems I&rsquo;ve encountered recently,
then it goes over to develop Rust code for an algorithm that we can easily use
to solve some Advent of Code problems, and we use it to make a solver for
sudoku puzzles. Along the way, we
explain the syntax we use, it shouldn&rsquo;t be too hard to understand for someone
who is unfamiliar with the language."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kaveland.no/posts/"},{"@type":"ListItem","position":2,"name":"Constraint propagation: Mutual recursion for fun and profit","item":"https://kaveland.no/posts/2025-03-10-mutual-recursion-for-fun-and-profit/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Constraint propagation: Mutual recursion for fun and profit","name":"Constraint propagation: Mutual recursion for fun and profit","description":"I\u0026rsquo;ve been wanting to write this post for a while, about what I think is an elegant way to solve some constraint satisfaction problems. Constraints tend to come up fairly often in real world programs, and some times it can be effective to treat them as constraint satisfaction problems. This post has a bit of background on constraint satisfaction problems I\u0026rsquo;ve encountered recently, then it goes over to develop Rust code for an algorithm that we can easily use to solve some Advent of Code problems, and we use it to make a solver for sudoku puzzles. Along the way, we explain the syntax we use, it shouldn\u0026rsquo;t be too hard to understand for someone who is unfamiliar with the language.\n","keywords":["rust","advent of code","algorithms"],"articleBody":"I’ve been wanting to write this post for a while, about what I think is an elegant way to solve some constraint satisfaction problems. Constraints tend to come up fairly often in real world programs, and some times it can be effective to treat them as constraint satisfaction problems. This post has a bit of background on constraint satisfaction problems I’ve encountered recently, then it goes over to develop Rust code for an algorithm that we can easily use to solve some Advent of Code problems, and we use it to make a solver for sudoku puzzles. Along the way, we explain the syntax we use, it shouldn’t be too hard to understand for someone who is unfamiliar with the language.\nIn fall 2022, my friend Jakob invited our team to take part in Advent of Code. I’d heard of this before, and decided to join, using it as an excuse to learn some Rust. I had a ton of fun, and decided that I wanted to complete all of the puzzles from both 2022 and earlier years. This has probably been one of my bigger side projects since. I’ve learned a ton and produced a lot of rust code. This later lead to eugene being written in Rust. All told, this is probably around 30-40k lines of Rust code on the hobby-side since 2022, and I’m still enjoying both Rust and Advent of Code.\nAdvent of Code 2018 day 16 A little while ago I wrapped up 2018 after a long break, and today I want to write a little bit about an elegant solution for one of the puzzles, namely 2018-16. There’s a lot of text there, and you don’t need to read all the details, the brief problem statement is this:\nWe are provided with 16 instructions for some sort of virtual machine. For each instruction, there’s a description of how it behaves. The virtual machine has 4 registers. An instruction runs with 3 arguments that are either references to a register, or an immediate value. For example:\n# instruction reg_a reg_b reg_c addr 2 3 0 # instruction reg_a immediate_b reg_c addi 2 14 0 This snippet says to run the addr instruction, which will look up the value in registers 2 and 3, add them together and write the result to register 0. The second example says to call addi, which will look up the value in register 2 and add the immediate operand 14 to it, writing the result to register 0.\nThere’s only one problem: We don’t have the opcodes of the different instructions. To figure that out, we are provided with many examples that look like this:\nBefore: [3, 2, 1, 1] 9 2 1 2 After: [3, 2, 2, 1] The before and after lines show us the register contents, and the line in the middle is the opcode of some unknown instruction, together with its 3 operands. The puzzle essentially boils down to figure out which opcode goes together with which instruction.\nPart 1 Part 1 of the puzzle points us in one possible direction to map the opcode and instruction pairs. It asks us to find out how many of the examples provided to us that behave like 3 or more of the instructions. This is an invitation to try to run all instructions across all the samples and verify whether the registers match the after-state. This isn’t very hard to do, let’s write some code. We’ll start by defining an Instruction enum, and implement the operations:\n#[derive(Copy, Clone, Debug, Eq, PartialEq)] enum Instruction { Addr, Addi, Mulr, Muli, Banr, Bani, Borr, Bori, Setr, Seti, Gtir, Gtri, Gtrr, Eqir, Eqri, Eqrr, } There’s not a lot of scary syntax here. By default, user-defined data types such as Instruction support almost no operations. The #[derive(..)] macro auto-implements some traits for us, which gives our Instruction type some capabilities, namely:\nCopy means Instruction is a value that doesn’t become invalid after having been moved / passed to someone else, like given to a function call. Clone gives us the .clone() call, which performs a copy explicitly. We aren’t allowed to say we’re Copy without also saying we’re Clone. Without Copy or Clone, data is “moved out of” our variable every time we send it somewhere (like a function call), so that the old variable would become invalid. Debug gives us the ability to use Instruction in format strings with the debug representation, which is great to have for test cases and debug-output. It makes things like println!(\"{instruction:?}\"); work. This is a lot like a .toString() in other languages. Eq and PartialEq give us == and !=, and we need PartialEq to get Eq, without this these operators aren’t defined for Instruction. To evaluate an instruction, it needs input registers, and it should calculate some output. Then, we just need to read the description very carefully to implement each instruction correctly:\nfn evaluate( instruction: Instruction, arg_a: usize, arg_b: usize, arg_c: usize, mut registers: [usize; 4], ) -\u003e [usize; 4] { use Instruction::*; registers[arg_c] = match instruction { Addr =\u003e registers[arg_a] + registers[arg_b], Addi =\u003e registers[arg_a] + arg_b, Mulr =\u003e registers[arg_a] * registers[arg_b], Muli =\u003e registers[arg_a] * arg_b, Banr =\u003e registers[arg_a] \u0026 registers[arg_b], Bani =\u003e registers[arg_a] \u0026 arg_b, Borr =\u003e registers[arg_a] | registers[arg_b], Bori =\u003e registers[arg_a] | arg_b, Setr =\u003e registers[arg_a], Seti =\u003e arg_a, Gtir =\u003e usize::from(arg_a \u003e registers[arg_b]), Gtri =\u003e usize::from(registers[arg_a] \u003e arg_b), Gtrr =\u003e usize::from(registers[arg_a] \u003e registers[arg_b]), Eqir =\u003e usize::from(arg_a == registers[arg_b]), Eqri =\u003e usize::from(registers[arg_a] == arg_b), Eqrr =\u003e usize::from(registers[arg_a] == registers[arg_b]), }; registers } } We settled for a usize for all integer values from the puzzle. It is an unsigned integer type used for indexing. We can use it here because there are no negative values present in the puzzle data, and no instruction can cause a value to become negative. This makes it convenient to index our registers: [usize; 4] array with no casting.\nSince registers is Copy, we are provided with our own copied value from our caller, and can just mutate it locally and return it, so the mut in front of the parameter name means only local mutability, our changes won’t be observable to whoever holds the original registers value. Other than that, we use Instruction::* to make the enum variants available without the Intruction:: prefix to make this huge match-block a little easier to look at. In Rust, bools can’t be implicitly converted to integer types, like in a lot of programming languages descended from C, so we do that manually using usize::from.\nNow we just need to parse the examples, and we’re ready to do part 1.\nThe input samples look like this:\nBefore: [3, 2, 1, 1] 9 2 1 2 After: [3, 2, 2, 1] There are 2 blank lines between each one. Since this is Advent of Code, we can afford to use some cheap tricks to parse the input. For example, we can just run a regex that identifies all numbers and group them into blocks of 4. This feels a little dirty, but for Advent of Code, that’s okay:\n#[derive(Copy, Clone, Debug, Eq, PartialEq, Default)] struct Example { before: [usize; 4], program: [usize; 4], after: [usize; 4], } fn parse(s: \u0026str) -\u003e impl Iterator\u003cItem = Example\u003e + '_ { let number = Regex::new(r\"\\d+\").unwrap(); s.split(\"\\n\\n\").map(move |ex| { let mut example = Example::default(); for (index, matched) in number.find_iter(ex).enumerate() { let n: usize = matched.as_str().parse().unwrap(); let rem = index % 4; match index / 4 { 0 =\u003e example.before[rem] = n, 1 =\u003e example.program[rem] = n, 2 =\u003e example.after[rem] = n, _ =\u003e panic!(\"Too many numbers in block: {index}, {ex}\"), } } example }) } The Example struct has a new trait derived, Default, which gives us the ability to call Example::default() to get an initialized value of the Example struct, with every struct member having its Default value. Arrays of numbers default to 0, which is fine here.\nSince the Iterator we return is only valid as long as the string we get a reference to, we have to add an anonymous lifetime to it using + '_. The compiler uses lifetimes to prove that nobody uses the Iterator we return after the string we reference has been removed. It would be nice if the compiler could hide this from us, and just take care of it under the covers, and maybe it will, at some point in the future.\nWe need to .unwrap() on our regex, because compiling a regex will fail if the regex syntax is illegal. Since this regex is hardcoded, we know it’ll always fail or always work. This would cause our program to crash if the regex was invalid, but that’s fine, it’s not recoverable without fixing the source code anyway.\nWe split the input string into blocks separated by double blanks. Then we map over each block. The |ex| part is lambda syntax: the move in front of it says that the lambda needs to take ownership of some variables that are local to parse, namely number (the regex). Otherwise, number would go out of scope and be deleted, and then it wouldn’t be okay for us to use it.\nWe match every number in each block. The .enumerate() iterator gives us the index of each match we find, and we use that to place the numbers we .parse() directly into the right place in our Example, which consists of 3 arrays of 4 numbers each.\nNow, it is easy to solve part 1 of the puzzle:\nuse Instruction::*; const ALL: [Instruction; 16] = [ Addr, Addi, Mulr, Muli, Banr, Bani, Borr, Bori, Setr, Seti, Gtir, Gtri, Gtrr, Eqir, Eqri, Eqrr, ]; fn compatible_instructions(example: \u0026Example) -\u003e usize { ALL.into_iter() .filter(|instruction| { let [_, arg_a, arg_b, arg_c] = example.program; let out = evaluate(*instruction, arg_a, arg_b, arg_c, example.before); out == example.after }) .count() } I don’t know of any way to get a handle of all of the variants of an enum, so we make an ALL array with all the instructions we know of. Then, to test which instructions that match the behavior observed in an example, we filter the instructions by whether they return the same output as the example or not. There’s a bit more syntax here; we chose to send the example to compatible_instructions by reference, saying we expect \u0026Example as input. We didn’t need to do this, since Example is Copy, but copying a reference may well be cheaper than copying 12 numbers.\nfilter receives a reference to whatever it is filtering, and since we chose to make evaluate take Instruction instead of \u0026Instruction for its first parameter, we must use * on it when passing it, which creates a copy (This wouldn’t work if Instruction wasn’t Copy).\nfn part_1(s: \u0026str) -\u003e usize { let (examples, _) = s.split_once(\"\\n\\n\\n\").unwrap(); parse(examples) .filter(|example| compatible_instructions(example) \u003e= 3) .count() } Finally, we parse the first section of the input, the one with the examples, then count how many examples that behave like at least 3 instructions.\nPart 2: Mutual recursion for fun and profit Part 2 asks us to map each instruction to its opcode, the opcode being the one provided as the first number in the program in the examples. It then asks us to run the program we’ve been provided as the second part of the puzzle input. By looking at the examples, we can see that the minimum opcode is 0 and the maximum opcode is 15, so we’re looking for a mapping between small integers.\nBefore we’ve seen any examples, we must assume that any opcode could refer to any instruction, so the mapping must initially be from 1 opcode to many possible instructions. Whenever we see a counter example, we eliminate that instruction from the mapping. If this results in only 1 remaining instruction, we choose that instruction to be that opcode. choose will eliminate that instruction from everywhere else. We will assume the existence of a few helper functions:\nchoice_made(options, place) -\u003e Option will give us Some(choice) if place is so constrained that there’s only one possible value. remove(options, place, instruction) -\u003e bool will remove instruction from the possible values for place, and return true if it did so and false if it had already been removed previously. set(options, place, instruction) will set instruction as the only possible value for place. With these helpers, our algorithm can be easily expressed like this in Rust:\nfn eliminate(options: \u0026mut Options, place: usize, instruction: usize) { // if we removed this instruction from place for the first time if remove(options, place, instruction) { // and there's only one possible choice left if let Some(choice) = choice_made(options, place) { // choose that choose(options, place, choice); } } } fn choose(options: \u0026mut Options, place: usize, instruction: usize) { set(options, place, instruction); for target in 0..options.len() { // since place is instruction, it can not be valid anywhere else if target != place { eliminate(options, target, instruction); } } } Note that here, we’re working with the type \u0026mut Options for options values. This is a reference which we can use to mutate the value that is passed to us, which is owned by our caller, it’s different than placing mut in front of the parameter name.\nThis is actually enough to solve a lot of constraint problems, it’s brief, to the point and I think it’s fairly elegant. To make it actually work, we need to encode Options somehow. This needs to be a mapping, and since we’re mapping between very small ints, an array should do fine. The value can be a 16-bit unsigned integer, where each bit refers to an index in the ALL array. Initially, all the bits should be on, because we don’t know anything yet:\ntype Options = [u16; 16]; // simply an alias fn initial_options() -\u003e Options { [0xffff; 16] // 0xffff is a 1-value for all 16 bits } fn is_possible(options: \u0026Options, place: usize, instruction: usize) -\u003e bool { // the bit that is index place is on options[place] \u0026 (1 \u003c\u003c instruction) \u003e 0 } fn set(options: \u0026mut Options, place: usize, instruction: usize) { options[place] = 1 \u003c\u003c instruction; } We need to be able to remove a candidate instruction for a place. It is convenient to let this return a bool telling us whether something was actually removed or not:\nfn remove(options: \u0026mut Options, place: usize, instruction: usize) -\u003e bool { let removed = is_possible(options, place, instruction); options[place] \u0026= !(1 \u003c\u003c instruction); removed } We need to be able check if a place has only a single candidate:\nfn choice_made(options: Options, place: usize) -\u003e Option\u003cusize\u003e { if options[place].count_ones() == 1 { Some(options[place].trailing_zeros() as usize) } else { None } } In here, .count_ones() is a builtin for integers in Rust that counts bits that are on, and .trailing_zeros() likewise counts trailing zero-bits in an int. And that’s it, our definition from earlier works now. Now we can identify all the opcodes by supplying counter-examples to eliminate:\nfn identify_opcodes(examples: \u0026[Example]) -\u003e [usize; 16] { let mut options = initial_options(); for (i, example) in examples.into_iter().enumerate() { let [opcode, arg_a, arg_b, arg_c] = example.program; for (place, instruction) in ALL.into_iter().enumerate() { let out = evaluate(instruction, arg_a, arg_b, arg_c, example.before); if out != example.after { eliminate(\u0026mut options, opcode, place); } } // Check if we're done if options.iter().all(|possible| possible.count_ones() == 1) { println!(\"Done after {i} of {} examples\", examples.len()); break; } } let mut choices = [0; 16]; for place in 0..options.len() { if let Some(choice) = choice_made(\u0026options, place) { choices[place] = choice; } } choices } On my input data, this prints Done after 29 of 806 examples. My input has more constraints than I need, probably in order to work with methods that don’t resolve all the constraints (perhaps a loop that just removes options that can’t work?).\nSolving part 2 requires us to establish the mapping and parse the second section of the input, which are lines of 4 numbers, which we’re to treat as opcode a b c and run the correct instruction on them.\nfn part_2(s: \u0026str) -\u003e usize { let (examples, program) = s.split_once(\"\\n\\n\\n\").unwrap(); let examples: Vec\u003c_\u003e = parse(examples).collect(); let mapping = identify_opcodes(\u0026examples); let mut registers = [0; 4]; let mut command = [0; 4]; let number = Regex::new(r\"\\d+\").unwrap(); for line in program.lines() { for (idx, n) in number.find_iter(line).enumerate() { command[idx] = n.as_str().parse().unwrap(); } let [opcode, arg_a, arg_b, arg_c] = command; registers = evaluate(ALL[mapping[opcode]], arg_a, arg_b, arg_c, registers); } registers[0] } Constraint propagation The core of the part 2 solution is the mutually recursive pair of functions I named choose/eliminate. Together, they make up an algorithm I know as constraint propagation. I’ve encountered exactly this kind of problem multiple times in Advent of Code now, I’ve rediscovered it for at least 3 days:\n2018-16 2020-16 2020-21 Though they all look different, I’ve solved them very similarly, with the main difference being the representation of the problem - bitmaps, like in this post, or hashmaps of sets, or matrices. We can use this solution because choosing a value in some place, constrains the possible values in another place. A lot of puzzles are like that.\nFor the most part, I don’t do much code reuse between different Advent of Code puzzles, I feel like rediscovering things I know is good for practice. But after doing this three times, I wanted to take a stab at making a generic version of it, and use it make a sudoku-solver. Sudoku is a bit different from the puzzles we’ve looked at so far. Instead of being able to eliminate everywhere other than where we’re choosing, we have to have some notion of neighbours (to return the 3x3 grid we’re in, our row, and our column). That’ll still work with the puzzle from earlier though, we’ll just say that everyone’s a neighbour in that one.\nSo, let’s try to implement something a little more generic:\ntrait Possibilities\u003cK: Copy, V: Copy\u003e { fn set(\u0026mut self, place: K, value: V); fn remove(\u0026mut self, place: K, value: V) -\u003e bool; fn choice_made(\u0026self, place: K) -\u003e Option\u003cV\u003e; fn neighbours(\u0026self, place: K) -\u003e impl Iterator\u003cItem = K\u003e; fn eliminate(\u0026mut self, place: K, value: V) { if self.remove(place, value) { if let Some(choice) = self.choice_made(place) { self.choose(place, choice); } } } fn choose(\u0026mut self, place: K, value: V) { self.set(place, value); for target in self.neighbours(place).collect::\u003cVec\u003c_\u003e\u003e() { self.eliminate(target, value); } } } This introduces a trait of 4 methods that must be provided, and 2 that are automatically provided. There’s a bit more syntax here. To provide an implementation of this trait, you must specify a K and a V type, that both implement Copy. K is like an index, or coordinate, and V is like a value that is a valid choice, like an Instruction or an index into the ALL array from earlier.\nImplementing it for a bitmap-based array, like the one from earlier could look like this:\nimpl\u003cconst N: usize\u003e Possibilities\u003cusize, usize\u003e for [u16; N] { fn set(\u0026mut self, place: usize, value: usize) { self[place] = 1 \u003c\u003c value; } fn remove(\u0026mut self, place: usize, value: usize) -\u003e bool { let bit = 1 \u003c\u003c value; let set = self[place] \u0026 bit; self[place] \u0026= !bit; set \u003e 0 } fn choice_made(\u0026self, place: usize) -\u003e Option\u003cusize\u003e { if self[place].count_ones() == 1 { Some(self[place].trailing_zeros() as usize) } else { None } } fn neighbours(\u0026self, place: usize) -\u003e impl Iterator\u003cItem = usize\u003e { (0..N).filter(move |n| *n != place) } } This uses const N: usize as a generic to enable it to work for arrays of any length. Note that since it’s still using u16, it doesn’t really make sense to use a higher value for N than 16 here. The change to identify_opcodes is very minor, we now call options.eliminate() instead of eliminate(\u0026mut options, ...) and options.choice_made() instead of choice_made(\u0026options), but other than that, it works the same as what we had earlier.\nSolving sudoku We have what we need in order to solve sudoku now, so let’s start pondering how to represent the board, and the possibilities. Each cell in sudoku can contain 9 possible numbers, so with the bitmask approach, that fits within 16 bits. There are 81 squares, and it might be convenient to index them with a pair of coordinates, but we can still represent it as a flat array in memory and just translate the lookups. Since there are only 9 possible numbers, we can use u8 as our value type.\nWe’ll make a simple wrapper around the array, so we can name types more easily:\n#[derive(Debug, Eq, PartialEq)] struct SudokuOptions { options: [u16; 81], } impl Default for SudokuOptions { fn default() -\u003e Self { // avoiding the zeroth bit will make it easier for us to make output later let everything_possible = ((1 \u003c\u003c 10) - 1) ^ 1; SudokuOptions { options: [everything_possible; 81], } } } We’ll use x, y coordinates to index into options. We know the width of the board to be 9, so x + y * 9 should give us the right spot. The remove and choice_made functions are similar to before, but neighbours is more involved. We floor-divide the x and y coordinates by 3, to truncate them to [0, 2]. Then we multiply that by 3 so get the first x, y coordinate of the “square” that contains (x, y). We iterate over the 9 cells in the square by using division and modulo by 3 to separate into x and y.\nimpl Possibilities\u003c(usize, usize), usize\u003e for SudokuOptions { fn remove(\u0026mut self, place: (usize, usize), value: usize) -\u003e bool { let ix = place.0 + place.1 * 9; let bit = 1 \u003c\u003c value; let set = self.options[ix] \u0026 bit; self.options[ix] \u0026= !bit; set \u003e 0 } fn choice_made(\u0026self, place: (usize, usize)) -\u003e Option\u003cusize\u003e { let ix = place.0 + place.1 * 9; if self.options[ix].count_ones() == 1 { Some(self.options[ix].trailing_zeros() as usize) } else { None } } fn neighbours(\u0026self, place: (usize, usize)) -\u003e impl Iterator\u003cItem = (usize, usize)\u003e { let (x, y) = place; let row = (0..9).map(move |x| (x, y)); let col = (0..9).map(move |y| (x, y)); let (xstart, ystart) = (3 * (x / 3), 3 * (y / 3)); let square = (0..9).map(move |s| (xstart + s / 3, ystart + s % 3)); row.chain(col) .chain(square) .filter(move |neighbour| *neighbour != place) } } We’ll need to call .choose() for each number we’re provided to solve the puzzle. If the puzzle has more than 1 possible solution, that won’t be enough, but we can think about that later. Let’s arbitrarily decide that our input is strings of 9 lines, where each line consists of 9 characters. The characters are either '.', to say that the character is unknown, or it is a number. Then, this should give us the solution for fully specified puzzles:\nfn sudoku(puzzle: \u0026str) -\u003e SudokuOptions { let mut board = SudokuOptions::default(); let known = puzzle.lines().enumerate().flat_map(|(y, line)| { line.as_bytes() .iter() .enumerate() .filter_map(move |(x, ch)| { if *ch != b'.' { Some(((x, y), *ch - b'0')) } else { None } }) }); for (place, value) in known { board.choose(place, value); } board } To test it, we’ll use the easy puzzle from wikipedia:\nconst EASY_PUZZLE: \u0026str = \"53..7.... 6..195... .98....6. 8...6...3 4..8.3..1 7...2...6 .6....28. ...419..5 ....8..79\" To compare, it would be nice to be able to make a string from a solved SudokuOptions, so let’s do that as well:\nimpl SudokuOptions { fn try_to_string(\u0026self) -\u003e Result\u003cString, String\u003e { let mut out = String::new(); for y in 0..9 { for x in 0..9 { if let Some(choice) = self.choice_made((x, y)) { out.push((choice + b'0') as char); } else { return Err(format!(\"{x}, {y} unresolved\")); } } out.push('\\n'); } Ok(out) } } And sure enough, running sudoku(EASY_PUZZLE) yields the answer:\n➜ sudoku git:(main) pbpaste| target/release/sudoku 534678912 672195348 198342567 859761423 426853791 713924856 961537284 287419635 345286179 In fact, this problem is over-constrained, and we don’t need every input value we’re provided with to solve it, exactly like with the instruction/opcode-mapping from earlier. For example, we can remove the 9 from the last cell, and the 9 next to 41 near the bottom, and it’ll still work. There are some improvements we could use here to make the solver a little more powerful. Namely, when we eliminate, we should check if it is the case that there exists some possibility in the row, column, or square that has not yet been chosen, but is the only location for that possibility within its row, column or square.\nIf, after doing that we find a problem that is under-constrained, we’ll need to try to apply some choices and just see if they work out, and currently the design we made won’t support that. We will need to modify it so that choose tells us whether the puzzle is still possible to solve, by identifying that a contradiction has happened, or whether all possible choices for some K have disappeared. I might do a followup on that later.\nThere’s a bit of additional code that was required for making it take input from stdin, which is available in a little repository I made from the code in this blogpost. The repository has code to solve Advent of Code 2018/16, as well as a sudoku-solver. Most of the code from this blogpost is there, although small refactorings were done to use the Possibilities trait instead of the functions working directly on [u16; 16].\n","wordCount":"4227","inLanguage":"en","datePublished":"2025-03-10T00:00:00Z","dateModified":"2025-03-10T00:00:00Z","author":{"@type":"Person","name":"Robin Kåveland"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kaveland.no/posts/2025-03-10-mutual-recursion-for-fun-and-profit/"},"publisher":{"@type":"Organization","name":"Robin's blog","logo":{"@type":"ImageObject","url":"https://kaveland.no/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kaveland.no/ accesskey=h title="Robin's blog (Alt + H)">Robin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kaveland.no/about/ title=about><span>about</span></a></li><li><a href=https://kaveland.no/projects/ title=projects><span>projects</span></a></li><li><a href=https://kaveland.no/eugene/ title=eugene><span>eugene</span></a></li><li><a href=https://kaveland.no/thumper/ title=thumper><span>thumper</span></a></li><li><a href=https://kaveland.no/tags/ title=tags><span>tags</span></a></li><li><a href=https://kaveland.no/archives/ title=archives><span>archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kaveland.no/>Home</a>&nbsp;»&nbsp;<a href=https://kaveland.no/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Constraint propagation: Mutual recursion for fun and profit</h1><div class=post-meta><span title='2025-03-10 00:00:00 +0000 UTC'>March 10, 2025</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;4227 words&nbsp;·&nbsp;Robin Kåveland&nbsp;|&nbsp;<a href=https://github.com/kaaveland/kaaveland.github.io/content/posts/2025-03-10-mutual-recursion-for-fun-and-profit.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#advent-of-code-2018-day-16>Advent of Code 2018 day 16</a><ul><li><a href=#part-1>Part 1</a></li><li><a href=#part-2-mutual-recursion-for-fun-and-profit>Part 2: Mutual recursion for fun and profit</a></li></ul></li><li><a href=#constraint-propagation>Constraint propagation</a></li><li><a href=#solving-sudoku>Solving sudoku</a></li></ul></nav></div></details></div><div class=post-content><p>I&rsquo;ve been wanting to write this post for a while, about what I think is an
elegant way to solve some <a href=https://en.wikipedia.org/wiki/Constraint_satisfaction_problem>constraint satisfaction
problems</a>. Constraints
tend to come up fairly often in real world programs, and some times it can be
effective to treat them as constraint satisfaction problems. This post has a bit
of background on constraint satisfaction problems I&rsquo;ve encountered recently,
then it goes over to develop Rust code for an algorithm that we can easily use
to solve some Advent of Code problems, and we use it to make a solver for
<a href=https://en.wikipedia.org/wiki/Sudoku>sudoku</a> puzzles. Along the way, we
explain the syntax we use, it shouldn&rsquo;t be too hard to understand for someone
who is unfamiliar with the language.</p><p>In fall 2022, my friend <a href=https://github.com/itzjacki/>Jakob</a> invited our
team to take part in <a href=https://adventofcode.com>Advent of Code</a>. I&rsquo;d heard of
this before, and decided to join, using it as an excuse to learn some Rust. I
had a ton of fun, and decided that I wanted to complete all of the puzzles from
both 2022 and earlier years. This has probably been one of my bigger side
projects since. I&rsquo;ve learned a ton and produced <a href=https://github.com/kaaveland/advent-of-code-rs>a lot of rust
code</a>. This later lead to
<a href=https://kaveland.no/eugene/>eugene</a> being written in Rust. All told, this is
probably around 30-40k lines of Rust code on the hobby-side since 2022, and I&rsquo;m
still enjoying both Rust and Advent of Code.</p><h2 id=advent-of-code-2018-day-16>Advent of Code 2018 day 16<a hidden class=anchor aria-hidden=true href=#advent-of-code-2018-day-16>#</a></h2><p>A little while ago I wrapped up <a href=https://adventofcode.com/2018>2018</a> after a
long break, and today I want to write a little bit about an elegant solution for
one of the puzzles, namely
<a href=https://adventofcode.com/2018/day/16>2018-16</a>. There&rsquo;s a lot of text there,
and you don&rsquo;t need to read all the details, the brief problem statement is
this:</p><p>We are provided with 16 <em>instructions</em> for some sort of virtual machine. For
each instruction, there&rsquo;s a description of how it behaves. The virtual machine
has 4 <em>registers</em>. An instruction runs with 3 arguments that are either
references to a register, or an <em>immediate</em> value. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># instruction reg_a reg_b reg_c</span>
</span></span><span class=line><span class=cl>addr <span class=m>2</span> <span class=m>3</span> <span class=m>0</span>
</span></span><span class=line><span class=cl><span class=c1># instruction reg_a immediate_b reg_c</span>
</span></span><span class=line><span class=cl>addi <span class=m>2</span> <span class=m>14</span> <span class=m>0</span>
</span></span></code></pre></div><p>This snippet says to run the <code>addr</code> <em>instruction</em>, which will look up the value
in <em>registers</em> <code>2</code> and <code>3</code>, add them together and write the result to register
<code>0</code>. The second example says to call <code>addi</code>, which will look up the value in
register 2 and add the <em>immediate</em> operand 14 to it, writing the result to
register 0.</p><p>There&rsquo;s only one problem: We don&rsquo;t have the <em>opcodes</em> of the different
instructions. To figure that out, we are provided with many examples that look
like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>Before: <span class=o>[</span>3, 2, 1, 1<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=m>9</span> <span class=m>2</span> <span class=m>1</span> <span class=m>2</span>
</span></span><span class=line><span class=cl>After:  <span class=o>[</span>3, 2, 2, 1<span class=o>]</span>
</span></span></code></pre></div><p>The before and after lines show us the <em>register</em> contents, and the line in the
middle is the <em>opcode</em> of some unknown <em>instruction</em>, together with its 3
operands. The puzzle essentially boils down to figure out which <em>opcode</em>
goes together with which <em>instruction</em>.</p><h3 id=part-1>Part 1<a hidden class=anchor aria-hidden=true href=#part-1>#</a></h3><p>Part 1 of the puzzle points us in one possible direction to map the <em>opcode</em>
and <em>instruction</em> pairs. It asks us to find out how many of the examples
provided to us that behave like 3 or more of the instructions. This is an
invitation to try to run all instructions across all the samples and verify
whether the registers match the after-state. This isn&rsquo;t very hard to do, let&rsquo;s
write some code. We&rsquo;ll start by defining an <code>Instruction</code> enum, and implement
the operations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Copy, Clone, Debug, Eq, PartialEq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>enum</span> <span class=nc>Instruction</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Addr</span><span class=p>,</span><span class=w> </span><span class=n>Addi</span><span class=p>,</span><span class=w> </span><span class=n>Mulr</span><span class=p>,</span><span class=w> </span><span class=n>Muli</span><span class=p>,</span><span class=w> </span><span class=n>Banr</span><span class=p>,</span><span class=w> </span><span class=n>Bani</span><span class=p>,</span><span class=w> </span><span class=n>Borr</span><span class=p>,</span><span class=w> </span><span class=n>Bori</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Setr</span><span class=p>,</span><span class=w> </span><span class=n>Seti</span><span class=p>,</span><span class=w> </span><span class=n>Gtir</span><span class=p>,</span><span class=w> </span><span class=n>Gtri</span><span class=p>,</span><span class=w> </span><span class=n>Gtrr</span><span class=p>,</span><span class=w> </span><span class=n>Eqir</span><span class=p>,</span><span class=w> </span><span class=n>Eqri</span><span class=p>,</span><span class=w> </span><span class=n>Eqrr</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>There&rsquo;s not a lot of scary syntax here. By default, user-defined data types such
as <code>Instruction</code> support almost no operations. The <code>#[derive(..)]</code> macro
auto-implements some traits for us, which gives our <code>Instruction</code> type some
capabilities, namely:</p><ul><li><code>Copy</code> means <code>Instruction</code> is a value that doesn&rsquo;t become invalid after having
been moved / passed to someone else, like given to a function call. <code>Clone</code>
gives us the <code>.clone()</code> call, which performs a copy explicitly. We aren&rsquo;t
allowed to say we&rsquo;re <code>Copy</code> without also saying we&rsquo;re <code>Clone</code>. Without <code>Copy</code>
or <code>Clone</code>, data is &ldquo;moved out of&rdquo; our variable every time we send it
somewhere (like a function call), so that the old variable would become
invalid.</li><li><code>Debug</code> gives us the ability to use <code>Instruction</code> in format strings with the
debug representation, which is great to have for test cases and
debug-output. It makes things like <code>println!("{instruction:?}");</code> work. This
is a lot like a <code>.toString()</code> in other languages.</li><li><code>Eq</code> and <code>PartialEq</code> give us <code>==</code> and <code>!=</code>, and we need <code>PartialEq</code> to get
<code>Eq</code>, without this these operators aren&rsquo;t defined for <code>Instruction</code>.</li></ul><p>To evaluate an instruction, it needs input registers, and it should calculate
some output. Then, we just need to read the description very carefully to
implement each instruction correctly:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>evaluate</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>instruction</span>: <span class=nc>Instruction</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>arg_a</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>arg_b</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>arg_c</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>mut</span><span class=w> </span><span class=n>registers</span>: <span class=p>[</span><span class=kt>usize</span><span class=p>;</span><span class=w> </span><span class=mi>4</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span>-&gt; <span class=p>[</span><span class=kt>usize</span><span class=p>;</span><span class=w> </span><span class=mi>4</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>use</span><span class=w> </span><span class=n>Instruction</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_c</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>instruction</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Addr</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_a</span><span class=p>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_b</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Addi</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_a</span><span class=p>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>arg_b</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Mulr</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_a</span><span class=p>]</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_b</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Muli</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_a</span><span class=p>]</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>arg_b</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Banr</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_a</span><span class=p>]</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_b</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Bani</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_a</span><span class=p>]</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=n>arg_b</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Borr</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_a</span><span class=p>]</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_b</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Bori</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_a</span><span class=p>]</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>arg_b</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Setr</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_a</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Seti</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>arg_a</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Gtir</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=kt>usize</span>::<span class=n>from</span><span class=p>(</span><span class=n>arg_a</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_b</span><span class=p>]),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Gtri</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=kt>usize</span>::<span class=n>from</span><span class=p>(</span><span class=n>registers</span><span class=p>[</span><span class=n>arg_a</span><span class=p>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>arg_b</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Gtrr</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=kt>usize</span>::<span class=n>from</span><span class=p>(</span><span class=n>registers</span><span class=p>[</span><span class=n>arg_a</span><span class=p>]</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_b</span><span class=p>]),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Eqir</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=kt>usize</span>::<span class=n>from</span><span class=p>(</span><span class=n>arg_a</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_b</span><span class=p>]),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Eqri</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=kt>usize</span>::<span class=n>from</span><span class=p>(</span><span class=n>registers</span><span class=p>[</span><span class=n>arg_a</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>arg_b</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Eqrr</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=kt>usize</span>::<span class=n>from</span><span class=p>(</span><span class=n>registers</span><span class=p>[</span><span class=n>arg_a</span><span class=p>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>registers</span><span class=p>[</span><span class=n>arg_b</span><span class=p>]),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>registers</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>We settled for a <code>usize</code> for all integer values from the puzzle. It is an
unsigned integer type used for indexing. We can use it here because there are no
negative values present in the puzzle data, and no instruction can cause a value
to become negative. This makes it convenient to index our <code>registers: [usize; 4]</code> array with no casting.</p><p>Since <code>registers</code> is <code>Copy</code>, we are provided with our own copied value from our
caller, and can just mutate it locally and return it, so the <code>mut</code> in front of
the parameter name means only local mutability, our changes won&rsquo;t be observable
to whoever holds the original <code>registers</code> value. Other than that, we <code>use Instruction::*</code> to make the enum variants available without the <code>Intruction::</code>
prefix to make this huge match-block a little easier to look at. In Rust,
<code>bool</code>s can&rsquo;t be implicitly converted to integer types, like in a lot of
programming languages descended from C, so we do that manually using
<code>usize::from</code>.</p><p>Now we just need to parse the examples, and we&rsquo;re ready to do part 1.</p><p>The input samples look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Before: [3, 2, 1, 1]
</span></span><span class=line><span class=cl>9 2 1 2
</span></span><span class=line><span class=cl>After:  [3, 2, 2, 1]
</span></span></code></pre></div><p>There are 2 blank lines between each one. Since this is Advent of Code, we can
afford to use some cheap tricks to parse the input. For example, we can just run
a regex that identifies all numbers and group them into blocks of 4. This feels
a little dirty, but for Advent of Code, that&rsquo;s okay:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Copy, Clone, Debug, Eq, PartialEq, Default)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Example</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>before</span>: <span class=p>[</span><span class=kt>usize</span><span class=p>;</span><span class=w> </span><span class=mi>4</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>program</span>: <span class=p>[</span><span class=kt>usize</span><span class=p>;</span><span class=w> </span><span class=mi>4</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>after</span>: <span class=p>[</span><span class=kt>usize</span><span class=p>;</span><span class=w> </span><span class=mi>4</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>parse</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Example</span><span class=o>&gt;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>&#39;_</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>number</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Regex</span>::<span class=n>new</span><span class=p>(</span><span class=sa>r</span><span class=s>&#34;\d+&#34;</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>s</span><span class=p>.</span><span class=n>split</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n\n</span><span class=s>&#34;</span><span class=p>).</span><span class=n>map</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=n>ex</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>example</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Example</span>::<span class=n>default</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>index</span><span class=p>,</span><span class=w> </span><span class=n>matched</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>number</span><span class=p>.</span><span class=n>find_iter</span><span class=p>(</span><span class=n>ex</span><span class=p>).</span><span class=n>enumerate</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>n</span>: <span class=kt>usize</span> <span class=o>=</span><span class=w> </span><span class=n>matched</span><span class=p>.</span><span class=n>as_str</span><span class=p>().</span><span class=n>parse</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>rem</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=mi>4</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>match</span><span class=w> </span><span class=n>index</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>4</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=mi>0</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>example</span><span class=p>.</span><span class=n>before</span><span class=p>[</span><span class=n>rem</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=mi>1</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>example</span><span class=p>.</span><span class=n>program</span><span class=p>[</span><span class=n>rem</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=mi>2</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>example</span><span class=p>.</span><span class=n>after</span><span class=p>[</span><span class=n>rem</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=fm>panic!</span><span class=p>(</span><span class=s>&#34;Too many numbers in block: </span><span class=si>{index}</span><span class=s>, </span><span class=si>{ex}</span><span class=s>&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>example</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The <code>Example</code> struct has a new trait derived, <code>Default</code>, which gives us the
ability to call <code>Example::default()</code> to get an initialized value of the
<code>Example</code> struct, with every struct member having its <code>Default</code> value. Arrays of
numbers default to 0, which is fine here.</p><p>Since the <code>Iterator</code> we return is only valid as long as the string we get a
reference to, we have to add an anonymous lifetime to it using <code>+ '_</code>. The
compiler uses lifetimes to <em>prove</em> that nobody uses the <code>Iterator</code> we return
after the string we reference has been removed. It would be nice if the compiler
could hide this from us, and just take care of it under the covers, and maybe it
will, at some point in the future.</p><p>We need to <code>.unwrap()</code> on our regex, because compiling a regex will fail if the
regex syntax is illegal. Since this regex is hardcoded, we know it&rsquo;ll always
fail or always work. This would cause our program to crash if the regex was
invalid, but that&rsquo;s fine, it&rsquo;s not recoverable without fixing the source code
anyway.</p><p>We split the input string into blocks separated by double blanks. Then we <code>map</code>
over each block. The <code>|ex|</code> part is lambda syntax: the <code>move</code> in front of it
says that the lambda needs to take ownership of some variables that
are local to <code>parse</code>, namely <code>number</code> (the regex). Otherwise, <code>number</code> would go
out of scope and be deleted, and then it wouldn&rsquo;t be okay for us to use it.</p><p>We match every number in each block. The <code>.enumerate()</code> iterator
gives us the <code>index</code> of each match we find, and we use that to place the numbers
we <code>.parse()</code> directly into the right place in our <code>Example</code>, which consists of
3 arrays of 4 numbers each.</p><p>Now, it is easy to solve part 1 of the puzzle:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>Instruction</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>const</span><span class=w> </span><span class=no>ALL</span>: <span class=p>[</span><span class=n>Instruction</span><span class=p>;</span><span class=w> </span><span class=mi>16</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Addr</span><span class=p>,</span><span class=w> </span><span class=n>Addi</span><span class=p>,</span><span class=w> </span><span class=n>Mulr</span><span class=p>,</span><span class=w> </span><span class=n>Muli</span><span class=p>,</span><span class=w> </span><span class=n>Banr</span><span class=p>,</span><span class=w> </span><span class=n>Bani</span><span class=p>,</span><span class=w> </span><span class=n>Borr</span><span class=p>,</span><span class=w> </span><span class=n>Bori</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Setr</span><span class=p>,</span><span class=w> </span><span class=n>Seti</span><span class=p>,</span><span class=w> </span><span class=n>Gtir</span><span class=p>,</span><span class=w> </span><span class=n>Gtri</span><span class=p>,</span><span class=w> </span><span class=n>Gtrr</span><span class=p>,</span><span class=w> </span><span class=n>Eqir</span><span class=p>,</span><span class=w> </span><span class=n>Eqri</span><span class=p>,</span><span class=w> </span><span class=n>Eqrr</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>compatible_instructions</span><span class=p>(</span><span class=n>example</span>: <span class=kp>&amp;</span><span class=nc>Example</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=no>ALL</span><span class=p>.</span><span class=n>into_iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>filter</span><span class=p>(</span><span class=o>|</span><span class=n>instruction</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=p>[</span><span class=n>_</span><span class=p>,</span><span class=w> </span><span class=n>arg_a</span><span class=p>,</span><span class=w> </span><span class=n>arg_b</span><span class=p>,</span><span class=w> </span><span class=n>arg_c</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>example</span><span class=p>.</span><span class=n>program</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>out</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>evaluate</span><span class=p>(</span><span class=o>*</span><span class=n>instruction</span><span class=p>,</span><span class=w> </span><span class=n>arg_a</span><span class=p>,</span><span class=w> </span><span class=n>arg_b</span><span class=p>,</span><span class=w> </span><span class=n>arg_c</span><span class=p>,</span><span class=w> </span><span class=n>example</span><span class=p>.</span><span class=n>before</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>out</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>example</span><span class=p>.</span><span class=n>after</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>count</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>I don&rsquo;t know of any way to get a handle of all of the variants of an <code>enum</code>, so
we make an <code>ALL</code> array with all the instructions we know of. Then, to test which
instructions that match the behavior observed in an example, we filter the
instructions by whether they return the same output as the example or
not. There&rsquo;s a bit more syntax here; we chose to send the <code>example</code> to
<code>compatible_instructions</code> by reference, saying we expect <code>&amp;Example</code> as input. We
didn&rsquo;t need to do this, since <code>Example</code> is <code>Copy</code>, but copying a reference may
well be cheaper than copying 12 numbers.</p><p><code>filter</code> receives a reference to whatever it is filtering, and since we chose to
make <code>evaluate</code> take <code>Instruction</code> instead of <code>&amp;Instruction</code> for its first
parameter, we must use <code>*</code> on it when passing it, which creates a copy (This
wouldn&rsquo;t work if <code>Instruction</code> wasn&rsquo;t <code>Copy</code>).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>part_1</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>examples</span><span class=p>,</span><span class=w> </span><span class=n>_</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>split_once</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n\n\n</span><span class=s>&#34;</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>parse</span><span class=p>(</span><span class=n>examples</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>filter</span><span class=p>(</span><span class=o>|</span><span class=n>example</span><span class=o>|</span><span class=w> </span><span class=n>compatible_instructions</span><span class=p>(</span><span class=n>example</span><span class=p>)</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=mi>3</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>count</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Finally, we parse the first section of the input, the one with the
examples, then count how many examples that behave like at least 3
<em>instructions</em>.</p><h3 id=part-2-mutual-recursion-for-fun-and-profit>Part 2: Mutual recursion for fun and profit<a hidden class=anchor aria-hidden=true href=#part-2-mutual-recursion-for-fun-and-profit>#</a></h3><p>Part 2 asks us to map each <em>instruction</em> to its <em>opcode</em>, the opcode being the
one provided as the first number in the program in the examples. It then asks us
to run the program we&rsquo;ve been provided as the second part of the puzzle
input. By looking at the examples, we can see that the minimum opcode is 0 and
the maximum opcode is 15, so we&rsquo;re looking for a mapping between small integers.</p><p>Before we&rsquo;ve seen any examples, we must assume that any opcode could refer to
any instruction, so the mapping must initially be from 1 opcode to many possible
instructions. Whenever we see a counter example, we <code>eliminate</code> that
<em>instruction</em> from the mapping. If this results in only 1 remaining
<em>instruction</em>, we <code>choose</code> that instruction to be that <em>opcode</em>. <code>choose</code> will
<code>eliminate</code> that instruction from everywhere else. We will assume the existence
of a few helper functions:</p><ul><li><code>choice_made(options, place) -> Option&lt;usize></code> will give us
<code>Some(choice)</code> if <code>place</code> is so constrained that there&rsquo;s only one possible
value.</li><li><code>remove(options, place, instruction) -> bool</code> will remove <code>instruction</code> from
the possible values for <code>place</code>, and return <code>true</code> if it did so and <code>false</code>
if it had already been removed previously.</li><li><code>set(options, place, instruction)</code> will set <code>instruction</code> as the only
possible value for <code>place</code>.</li></ul><p>With these helpers, our algorithm can be easily expressed like this in Rust:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>eliminate</span><span class=p>(</span><span class=n>options</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Options</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>instruction</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// if we removed this instruction from place for the first time
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>remove</span><span class=p>(</span><span class=n>options</span><span class=p>,</span><span class=w> </span><span class=n>place</span><span class=p>,</span><span class=w> </span><span class=n>instruction</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// and there&#39;s only one possible choice left
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>choice</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>choice_made</span><span class=p>(</span><span class=n>options</span><span class=p>,</span><span class=w> </span><span class=n>place</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// choose that
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=n>choose</span><span class=p>(</span><span class=n>options</span><span class=p>,</span><span class=w> </span><span class=n>place</span><span class=p>,</span><span class=w> </span><span class=n>choice</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>choose</span><span class=p>(</span><span class=n>options</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Options</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>instruction</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>set</span><span class=p>(</span><span class=n>options</span><span class=p>,</span><span class=w> </span><span class=n>place</span><span class=p>,</span><span class=w> </span><span class=n>instruction</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>target</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=o>..</span><span class=n>options</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// since place is instruction, it can not be valid anywhere else
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>target</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>place</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>eliminate</span><span class=p>(</span><span class=n>options</span><span class=p>,</span><span class=w> </span><span class=n>target</span><span class=p>,</span><span class=w> </span><span class=n>instruction</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Note that here, we&rsquo;re working with the type <code>&amp;mut Options</code> for <code>options</code>
values. This is a reference which we can use to mutate the value that is passed
to us, which is owned by our caller, it&rsquo;s different than placing <code>mut</code> in front
of the parameter name.</p><p>This is actually enough to solve a lot of constraint problems, it&rsquo;s brief, to
the point and I think it&rsquo;s fairly elegant. To make it actually work, we need to
encode <code>Options</code> somehow. This needs to be a mapping, and since we&rsquo;re mapping
between very small ints, an array should do fine. The value can be a 16-bit
unsigned integer, where each bit refers to an index in the <code>ALL</code>
array. Initially, all the bits should be on, because we don&rsquo;t know anything yet:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>type</span> <span class=nc>Options</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=kt>u16</span><span class=p>;</span><span class=w> </span><span class=mi>16</span><span class=p>];</span><span class=w> </span><span class=c1>// simply an alias
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>initial_options</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Options</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>[</span><span class=mh>0xffff</span><span class=p>;</span><span class=w> </span><span class=mi>16</span><span class=p>]</span><span class=w> </span><span class=c1>// 0xffff is a 1-value for all 16 bits
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>is_possible</span><span class=p>(</span><span class=n>options</span>: <span class=kp>&amp;</span><span class=nc>Options</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>instruction</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// the bit that is index place is on
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>options</span><span class=p>[</span><span class=n>place</span><span class=p>]</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=p>(</span><span class=mi>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>instruction</span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>set</span><span class=p>(</span><span class=n>options</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Options</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>instruction</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>options</span><span class=p>[</span><span class=n>place</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>instruction</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>We need to be able to remove a candidate <code>instruction</code> for a <code>place</code>. It is
convenient to let this return a bool telling us whether something was actually
removed or not:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>remove</span><span class=p>(</span><span class=n>options</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=n>Options</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>instruction</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>removed</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>is_possible</span><span class=p>(</span><span class=n>options</span><span class=p>,</span><span class=w> </span><span class=n>place</span><span class=p>,</span><span class=w> </span><span class=n>instruction</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>options</span><span class=p>[</span><span class=n>place</span><span class=p>]</span><span class=w> </span><span class=o>&amp;=</span><span class=w> </span><span class=o>!</span><span class=p>(</span><span class=mi>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>instruction</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>removed</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>We need to be able check if a <code>place</code> has only a single candidate:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>choice_made</span><span class=p>(</span><span class=n>options</span>: <span class=nc>Options</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>options</span><span class=p>[</span><span class=n>place</span><span class=p>].</span><span class=n>count_ones</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>options</span><span class=p>[</span><span class=n>place</span><span class=p>].</span><span class=n>trailing_zeros</span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>None</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>In here, <code>.count_ones()</code> is a builtin for integers in Rust that counts bits that
are on, and <code>.trailing_zeros()</code> likewise counts trailing zero-bits in an int.
And that&rsquo;s it, our definition from earlier works now. Now we can identify all
the <em>opcodes</em> by supplying counter-examples to <code>eliminate</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>identify_opcodes</span><span class=p>(</span><span class=n>examples</span>: <span class=kp>&amp;</span><span class=p>[</span><span class=n>Example</span><span class=p>])</span><span class=w> </span>-&gt; <span class=p>[</span><span class=kt>usize</span><span class=p>;</span><span class=w> </span><span class=mi>16</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>options</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>initial_options</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>example</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>examples</span><span class=p>.</span><span class=n>into_iter</span><span class=p>().</span><span class=n>enumerate</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>[</span><span class=n>opcode</span><span class=p>,</span><span class=w> </span><span class=n>arg_a</span><span class=p>,</span><span class=w> </span><span class=n>arg_b</span><span class=p>,</span><span class=w> </span><span class=n>arg_c</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>example</span><span class=p>.</span><span class=n>program</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>place</span><span class=p>,</span><span class=w> </span><span class=n>instruction</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=no>ALL</span><span class=p>.</span><span class=n>into_iter</span><span class=p>().</span><span class=n>enumerate</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>out</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>evaluate</span><span class=p>(</span><span class=n>instruction</span><span class=p>,</span><span class=w> </span><span class=n>arg_a</span><span class=p>,</span><span class=w> </span><span class=n>arg_b</span><span class=p>,</span><span class=w> </span><span class=n>arg_c</span><span class=p>,</span><span class=w> </span><span class=n>example</span><span class=p>.</span><span class=n>before</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>out</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>example</span><span class=p>.</span><span class=n>after</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>eliminate</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>options</span><span class=p>,</span><span class=w> </span><span class=n>opcode</span><span class=p>,</span><span class=w> </span><span class=n>place</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Check if we&#39;re done
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=n>options</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>all</span><span class=p>(</span><span class=o>|</span><span class=n>possible</span><span class=o>|</span><span class=w> </span><span class=n>possible</span><span class=p>.</span><span class=n>count_ones</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Done after </span><span class=si>{i}</span><span class=s> of </span><span class=si>{}</span><span class=s> examples&#34;</span><span class=p>,</span><span class=w> </span><span class=n>examples</span><span class=p>.</span><span class=n>len</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>choices</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=mi>16</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>place</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=o>..</span><span class=n>options</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>choice</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>choice_made</span><span class=p>(</span><span class=o>&amp;</span><span class=n>options</span><span class=p>,</span><span class=w> </span><span class=n>place</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>choices</span><span class=p>[</span><span class=n>place</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>choice</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>choices</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>On my input data, this prints <code>Done after 29 of 806 examples</code>. My input has more
constraints than I need, probably in order to work with methods that don&rsquo;t
resolve all the constraints (perhaps a loop that just removes options that can&rsquo;t
work?).</p><p>Solving part 2 requires us to establish the mapping and parse the second section
of the input, which are lines of 4 numbers, which we&rsquo;re to treat as <code>opcode a b c</code> and run the correct instruction on them.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>part_2</span><span class=p>(</span><span class=n>s</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>examples</span><span class=p>,</span><span class=w> </span><span class=n>program</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>split_once</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n\n\n</span><span class=s>&#34;</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>examples</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>_</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>parse</span><span class=p>(</span><span class=n>examples</span><span class=p>).</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>mapping</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>identify_opcodes</span><span class=p>(</span><span class=o>&amp;</span><span class=n>examples</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>registers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=mi>4</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>command</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=mi>4</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>number</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Regex</span>::<span class=n>new</span><span class=p>(</span><span class=sa>r</span><span class=s>&#34;\d+&#34;</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>line</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>program</span><span class=p>.</span><span class=n>lines</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>idx</span><span class=p>,</span><span class=w> </span><span class=n>n</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>number</span><span class=p>.</span><span class=n>find_iter</span><span class=p>(</span><span class=n>line</span><span class=p>).</span><span class=n>enumerate</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>command</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=p>.</span><span class=n>as_str</span><span class=p>().</span><span class=n>parse</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>[</span><span class=n>opcode</span><span class=p>,</span><span class=w> </span><span class=n>arg_a</span><span class=p>,</span><span class=w> </span><span class=n>arg_b</span><span class=p>,</span><span class=w> </span><span class=n>arg_c</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>command</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>registers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>evaluate</span><span class=p>(</span><span class=no>ALL</span><span class=p>[</span><span class=n>mapping</span><span class=p>[</span><span class=n>opcode</span><span class=p>]],</span><span class=w> </span><span class=n>arg_a</span><span class=p>,</span><span class=w> </span><span class=n>arg_b</span><span class=p>,</span><span class=w> </span><span class=n>arg_c</span><span class=p>,</span><span class=w> </span><span class=n>registers</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>registers</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=constraint-propagation>Constraint propagation<a hidden class=anchor aria-hidden=true href=#constraint-propagation>#</a></h2><p>The core of the part 2 solution is the mutually recursive pair of functions I
named <code>choose/eliminate</code>. Together, they make up an algorithm I know as
constraint propagation. I&rsquo;ve encountered exactly this kind of problem multiple
times in Advent of Code now, I&rsquo;ve rediscovered it for at least 3 days:</p><ul><li><a href=https://adventofcode.com/2018/day/16>2018-16</a></li><li><a href=https://adventofcode.com/2020/day/16>2020-16</a></li><li><a href=https://adventofcode.com/2020/day/21>2020-21</a></li></ul><p>Though they all look different, I&rsquo;ve solved them very similarly, with the main
difference being the representation of the problem - bitmaps, like in this post,
or hashmaps of sets, or matrices. We can use this solution because <em>choosing</em> a
value in some place, <em>constrains</em> the possible values in another place. A lot of
puzzles are like that.</p><p>For the most part, I don&rsquo;t do much code reuse between different Advent of Code
puzzles, I feel like rediscovering things I know is good for practice. But after
doing this three times, I wanted to take a stab at making a generic version of
it, and use it make a sudoku-solver. Sudoku is a bit different from the puzzles
we&rsquo;ve looked at so far. Instead of being able to eliminate <em>everywhere</em> other
than where we&rsquo;re choosing, we have to have some notion of <em>neighbours</em> (to
return the 3x3 grid we&rsquo;re in, our row, and our column). That&rsquo;ll still work with
the puzzle from earlier though, we&rsquo;ll just say that everyone&rsquo;s a neighbour in
that one.</p><p>So, let&rsquo;s try to implement something a little more generic:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>trait</span><span class=w> </span><span class=n>Possibilities</span><span class=o>&lt;</span><span class=n>K</span>: <span class=nb>Copy</span><span class=p>,</span><span class=w> </span><span class=n>V</span>: <span class=nb>Copy</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>set</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=nc>K</span><span class=p>,</span><span class=w> </span><span class=n>value</span>: <span class=nc>V</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>remove</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=nc>K</span><span class=p>,</span><span class=w> </span><span class=n>value</span>: <span class=nc>V</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>choice_made</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=nc>K</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=n>V</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>neighbours</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=nc>K</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>K</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>eliminate</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=nc>K</span><span class=p>,</span><span class=w> </span><span class=n>value</span>: <span class=nc>V</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>remove</span><span class=p>(</span><span class=n>place</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>choice</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>choice_made</span><span class=p>(</span><span class=n>place</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=bp>self</span><span class=p>.</span><span class=n>choose</span><span class=p>(</span><span class=n>place</span><span class=p>,</span><span class=w> </span><span class=n>choice</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>choose</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=nc>K</span><span class=p>,</span><span class=w> </span><span class=n>value</span>: <span class=nc>V</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=n>place</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>target</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>neighbours</span><span class=p>(</span><span class=n>place</span><span class=p>).</span><span class=n>collect</span>::<span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>_</span><span class=o>&gt;&gt;</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=bp>self</span><span class=p>.</span><span class=n>eliminate</span><span class=p>(</span><span class=n>target</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This introduces a trait of 4 methods that must be provided, and 2 that are
automatically provided. There&rsquo;s a bit more syntax here. To provide an
implementation of this trait, you must specify a <code>K</code> and a <code>V</code> type, that both
implement <code>Copy</code>. <code>K</code> is like an index, or coordinate, and <code>V</code> is like a value
that is a valid choice, like an <code>Instruction</code> or an index into the <code>ALL</code> array
from earlier.</p><p>Implementing it for a bitmap-based array, like the one from earlier could look
like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=o>&lt;</span><span class=k>const</span><span class=w> </span><span class=n>N</span>: <span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=n>Possibilities</span><span class=o>&lt;</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=p>[</span><span class=kt>u16</span><span class=p>;</span><span class=w> </span><span class=n>N</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>set</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>value</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>[</span><span class=n>place</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>remove</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=n>value</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>bit</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>set</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>[</span><span class=n>place</span><span class=p>]</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=n>bit</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>[</span><span class=n>place</span><span class=p>]</span><span class=w> </span><span class=o>&amp;=</span><span class=w> </span><span class=o>!</span><span class=n>bit</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>set</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>choice_made</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>[</span><span class=n>place</span><span class=p>].</span><span class=n>count_ones</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=bp>self</span><span class=p>[</span><span class=n>place</span><span class=p>].</span><span class=n>trailing_zeros</span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>None</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>neighbours</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>(</span><span class=mi>0</span><span class=o>..</span><span class=n>N</span><span class=p>).</span><span class=n>filter</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=n>n</span><span class=o>|</span><span class=w> </span><span class=o>*</span><span class=n>n</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>place</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This uses <code>const N: usize</code> as a generic to enable it to work for arrays of any
length. Note that since it&rsquo;s still using <code>u16</code>, it doesn&rsquo;t really make sense to
use a higher value for <code>N</code> than 16 here. The change to <code>identify_opcodes</code> is
very minor, we now call <code>options.eliminate()</code> instead of <code>eliminate(&amp;mut options, ...)</code> and <code>options.choice_made()</code> instead of <code>choice_made(&amp;options)</code>, but other
than that, it works the same as what we had earlier.</p><h2 id=solving-sudoku>Solving sudoku<a hidden class=anchor aria-hidden=true href=#solving-sudoku>#</a></h2><p>We have what we need in order to solve sudoku now, so let&rsquo;s start pondering how
to represent the board, and the possibilities. Each cell in sudoku can contain 9
possible numbers, so with the bitmask approach, that fits within 16 bits. There
are 81 squares, and it might be convenient to index them with a pair of
coordinates, but we can still represent it as a flat array in memory and just
translate the lookups. Since there are only 9 possible numbers, we can use
<code>u8</code> as our value type.</p><p>We&rsquo;ll make a simple wrapper around the array, so we can name types more easily:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Debug, Eq, PartialEq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>SudokuOptions</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>options</span>: <span class=p>[</span><span class=kt>u16</span><span class=p>;</span><span class=w> </span><span class=mi>81</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=nb>Default</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SudokuOptions</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>default</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// avoiding the zeroth bit will make it easier for us to make output later
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>everything_possible</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>((</span><span class=mi>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=mi>10</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=o>^</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>SudokuOptions</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>options</span>: <span class=p>[</span><span class=n>everything_possible</span><span class=p>;</span><span class=w> </span><span class=mi>81</span><span class=p>],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>We&rsquo;ll use x, y coordinates to index into <code>options</code>. We know the width of the
board to be 9, so <code>x + y * 9</code> should give us the right spot. The <code>remove</code> and
<code>choice_made</code> functions are similar to before, but <code>neighbours</code> is more
involved. We floor-divide the <code>x</code> and <code>y</code> coordinates by 3, to truncate them
to <code>[0, 2]</code>. Then we multiply that by 3 so get the first <code>x, y</code> coordinate of
the &ldquo;square&rdquo; that contains <code>(x, y)</code>. We iterate over the 9 cells in the square
by using division and modulo by 3 to separate into <code>x</code> and <code>y</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>Possibilities</span><span class=o>&lt;</span><span class=p>(</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=kt>usize</span><span class=p>),</span><span class=w> </span><span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>SudokuOptions</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>remove</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=p>(</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=kt>usize</span><span class=p>),</span><span class=w> </span><span class=n>value</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>ix</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>place</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>place</span><span class=p>.</span><span class=mi>1</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>9</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>bit</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>set</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>options</span><span class=p>[</span><span class=n>ix</span><span class=p>]</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=n>bit</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>options</span><span class=p>[</span><span class=n>ix</span><span class=p>]</span><span class=w> </span><span class=o>&amp;=</span><span class=w> </span><span class=o>!</span><span class=n>bit</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>set</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>choice_made</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=p>(</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=kt>usize</span><span class=p>))</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=kt>usize</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>ix</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>place</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>place</span><span class=p>.</span><span class=mi>1</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>9</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>options</span><span class=p>[</span><span class=n>ix</span><span class=p>].</span><span class=n>count_ones</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>options</span><span class=p>[</span><span class=n>ix</span><span class=p>].</span><span class=n>trailing_zeros</span><span class=p>()</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>usize</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>None</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>neighbours</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>place</span>: <span class=p>(</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=kt>usize</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=kt>usize</span><span class=p>,</span><span class=w> </span><span class=kt>usize</span><span class=p>)</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>place</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>row</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=o>..</span><span class=mi>9</span><span class=p>).</span><span class=n>map</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=n>x</span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>col</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=o>..</span><span class=mi>9</span><span class=p>).</span><span class=n>map</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=n>y</span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=p>(</span><span class=n>xstart</span><span class=p>,</span><span class=w> </span><span class=n>ystart</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>3</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>3</span><span class=p>),</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>y</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>3</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>square</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=o>..</span><span class=mi>9</span><span class=p>).</span><span class=n>map</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=n>s</span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>xstart</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>3</span><span class=p>,</span><span class=w> </span><span class=n>ystart</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=mi>3</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>row</span><span class=p>.</span><span class=n>chain</span><span class=p>(</span><span class=n>col</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>chain</span><span class=p>(</span><span class=n>square</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>filter</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=n>neighbour</span><span class=o>|</span><span class=w> </span><span class=o>*</span><span class=n>neighbour</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>place</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>We&rsquo;ll need to call <code>.choose()</code> for each number we&rsquo;re provided to solve the
puzzle. If the puzzle has more than 1 possible solution, that won&rsquo;t be enough,
but we can think about that later. Let&rsquo;s arbitrarily decide that our input is
strings of 9 lines, where each line consists of 9 characters. The characters
are either <code>'.'</code>, to say that the character is unknown, or it is a
number. Then, this should give us the solution for fully specified puzzles:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>sudoku</span><span class=p>(</span><span class=n>puzzle</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>SudokuOptions</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>board</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SudokuOptions</span>::<span class=n>default</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>known</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>puzzle</span><span class=p>.</span><span class=n>lines</span><span class=p>().</span><span class=n>enumerate</span><span class=p>().</span><span class=n>flat_map</span><span class=p>(</span><span class=o>|</span><span class=p>(</span><span class=n>y</span><span class=p>,</span><span class=w> </span><span class=n>line</span><span class=p>)</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>line</span><span class=p>.</span><span class=n>as_bytes</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>enumerate</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>filter_map</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>ch</span><span class=p>)</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=o>*</span><span class=n>ch</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=sa>b</span><span class=sc>&#39;.&#39;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=nb>Some</span><span class=p>(((</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>),</span><span class=w> </span><span class=o>*</span><span class=n>ch</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=sa>b</span><span class=sc>&#39;0&#39;</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=nb>None</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>place</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>known</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>board</span><span class=p>.</span><span class=n>choose</span><span class=p>(</span><span class=n>place</span><span class=p>,</span><span class=w> </span><span class=n>value</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>board</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>To test it, we&rsquo;ll use the easy puzzle from
<a href=https://en.wikipedia.org/wiki/Sudoku#/media/File:Sudoku_Puzzle_by_L2G-20050714_standardized_layout.svg>wikipedia</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>const</span><span class=w> </span><span class=no>EASY_PUZZLE</span>: <span class=kp>&amp;</span><span class=kt>str</span> <span class=o>=</span><span class=w> </span><span class=s>&#34;53..7....
</span></span></span><span class=line><span class=cl><span class=s>6..195...
</span></span></span><span class=line><span class=cl><span class=s>.98....6.
</span></span></span><span class=line><span class=cl><span class=s>8...6...3
</span></span></span><span class=line><span class=cl><span class=s>4..8.3..1
</span></span></span><span class=line><span class=cl><span class=s>7...2...6
</span></span></span><span class=line><span class=cl><span class=s>.6....28.
</span></span></span><span class=line><span class=cl><span class=s>...419..5
</span></span></span><span class=line><span class=cl><span class=s>....8..79&#34;</span><span class=w>
</span></span></span></code></pre></div><p>To compare, it would be nice to be able to make a string from a solved
<code>SudokuOptions</code>, so let&rsquo;s do that as well:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=n>SudokuOptions</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>try_to_string</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=nb>String</span><span class=p>,</span><span class=w> </span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>out</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>y</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=o>..</span><span class=mi>9</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=mi>0</span><span class=o>..</span><span class=mi>9</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>choice</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>choice_made</span><span class=p>((</span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=n>y</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>out</span><span class=p>.</span><span class=n>push</span><span class=p>((</span><span class=n>choice</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=sa>b</span><span class=sc>&#39;0&#39;</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=kt>char</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{x}</span><span class=s>, </span><span class=si>{y}</span><span class=s> unresolved&#34;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>out</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=sc>&#39;\n&#39;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Ok</span><span class=p>(</span><span class=n>out</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>And sure enough, running <code>sudoku(EASY_PUZZLE)</code> yields the answer:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>➜  sudoku git:<span class=o>(</span>main<span class=o>)</span> pbpaste<span class=p>|</span> target/release/sudoku
</span></span><span class=line><span class=cl><span class=m>534678912</span>
</span></span><span class=line><span class=cl><span class=m>672195348</span>
</span></span><span class=line><span class=cl><span class=m>198342567</span>
</span></span><span class=line><span class=cl><span class=m>859761423</span>
</span></span><span class=line><span class=cl><span class=m>426853791</span>
</span></span><span class=line><span class=cl><span class=m>713924856</span>
</span></span><span class=line><span class=cl><span class=m>961537284</span>
</span></span><span class=line><span class=cl><span class=m>287419635</span>
</span></span><span class=line><span class=cl><span class=m>345286179</span>
</span></span></code></pre></div><p>In fact, this problem is over-constrained, and we don&rsquo;t need every input value
we&rsquo;re provided with to solve it, exactly like with the
instruction/opcode-mapping from earlier. For example, we can remove the 9 from
the last cell, and the 9 next to 41 near the bottom, and it&rsquo;ll still work. There
are some improvements we could use here to make the solver a little more
powerful. Namely, when we eliminate, we should check if it is the case that there
exists some possibility in the row, column, or square that has not yet been
chosen, but is the only location for that possibility within its row, column or
square.</p><p>If, after doing that we find a problem that is under-constrained, we&rsquo;ll need to
try to apply some choices and just see if they work out, and currently the
design we made won&rsquo;t support that. We will need to modify it so that <code>choose</code>
tells us whether the puzzle is still possible to solve, by identifying that a
contradiction has happened, or whether all possible choices for some <code>K</code> have
disappeared. I might do a followup on that later.</p><p>There&rsquo;s a bit of additional code that was required for making it take input from
stdin, which is available in a little
<a href=https://github.com/kaaveland/sudoku-rs/tree/main>repository</a> I made from the
code in this blogpost. The repository has code to solve Advent of Code 2018/16,
as well as a sudoku-solver. Most of the code from this blogpost is there,
although small refactorings were done to use the <code>Possibilities</code> trait instead
of the functions working directly on <code>[u16; 16]</code>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kaveland.no/tags/rust/>Rust</a></li><li><a href=https://kaveland.no/tags/advent-of-code/>Advent of Code</a></li><li><a href=https://kaveland.no/tags/algorithms/>Algorithms</a></li></ul><nav class=paginav><a class=prev href=https://kaveland.no/posts/2025-04-04-finding-missing-indexes-in-pg-catalog/><span class=title>« Prev</span><br><span>Finding foreign keys missing indexes</span>
</a><a class=next href=https://kaveland.no/posts/2025-03-02-can-i-just-use-postgres/><span class=title>Next »</span><br><span>Why would I use DuckDB for that?</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Constraint propagation: Mutual recursion for fun and profit on x" href="https://x.com/intent/tweet/?text=Constraint%20propagation%3a%20Mutual%20recursion%20for%20fun%20and%20profit&amp;url=https%3a%2f%2fkaveland.no%2fposts%2f2025-03-10-mutual-recursion-for-fun-and-profit%2f&amp;hashtags=rust%2cadventofcode%2calgorithms"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Constraint propagation: Mutual recursion for fun and profit on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkaveland.no%2fposts%2f2025-03-10-mutual-recursion-for-fun-and-profit%2f&amp;title=Constraint%20propagation%3a%20Mutual%20recursion%20for%20fun%20and%20profit&amp;summary=Constraint%20propagation%3a%20Mutual%20recursion%20for%20fun%20and%20profit&amp;source=https%3a%2f%2fkaveland.no%2fposts%2f2025-03-10-mutual-recursion-for-fun-and-profit%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Constraint propagation: Mutual recursion for fun and profit on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkaveland.no%2fposts%2f2025-03-10-mutual-recursion-for-fun-and-profit%2f&title=Constraint%20propagation%3a%20Mutual%20recursion%20for%20fun%20and%20profit"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Constraint propagation: Mutual recursion for fun and profit on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkaveland.no%2fposts%2f2025-03-10-mutual-recursion-for-fun-and-profit%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Constraint propagation: Mutual recursion for fun and profit on whatsapp" href="https://api.whatsapp.com/send?text=Constraint%20propagation%3a%20Mutual%20recursion%20for%20fun%20and%20profit%20-%20https%3a%2f%2fkaveland.no%2fposts%2f2025-03-10-mutual-recursion-for-fun-and-profit%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Constraint propagation: Mutual recursion for fun and profit on telegram" href="https://telegram.me/share/url?text=Constraint%20propagation%3a%20Mutual%20recursion%20for%20fun%20and%20profit&amp;url=https%3a%2f%2fkaveland.no%2fposts%2f2025-03-10-mutual-recursion-for-fun-and-profit%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Constraint propagation: Mutual recursion for fun and profit on ycombinator" href="https://news.ycombinator.com/submitlink?t=Constraint%20propagation%3a%20Mutual%20recursion%20for%20fun%20and%20profit&u=https%3a%2f%2fkaveland.no%2fposts%2f2025-03-10-mutual-recursion-for-fun-and-profit%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kaveland.no/>Robin's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>