<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Using SQL to turn all the buses around | Robin's blog</title>
<meta name=keywords content="data,sql,duckdb,seaborn,visualization"><meta name=description content="I have a small hobby project over at kollektivkart.arktekk.no that is for visualizing changes in public transit in Norway. For some time I&rsquo;ve been wanting to do some visualizations on public transit lines. For example, plot the mean delay at each stop used by a line over time.
When trying to do some concept work on this, I discovered a puzzle in the data! Many lines go in two opposite directions. Here in Trondheim, Line 3 goes from Loholt to Hallset, but also from Hallset to Loholt. The way I can tell these apart is to look up the direction in the data. Within a line, there can be variations in each direction. Some services might skip some stops, or depending on how you look at it, others visit extra stops. But these are variations on a theme, and it probably makes sense to group them together to preserve our sanity and not get 12 different plots for each line—2 should be plenty!"><meta name=author content="Robin Kåveland"><link rel=canonical href=https://kaveland.no/posts/2025-05-28-turning-the-bus-sql/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://kaveland.no/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kaveland.no/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kaveland.no/favicon-32x32.png><link rel=apple-touch-icon href=https://kaveland.no/apple-touch-icon.png><link rel=mask-icon href=https://kaveland.no/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kaveland.no/posts/2025-05-28-turning-the-bus-sql/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer data-domain=kaveland.no src=https://plausible.io/js/script.js></script><meta property="og:title" content="Using SQL to turn all the buses around"><meta property="og:description" content="I have a small hobby project over at kollektivkart.arktekk.no that is for visualizing changes in public transit in Norway. For some time I&rsquo;ve been wanting to do some visualizations on public transit lines. For example, plot the mean delay at each stop used by a line over time.
When trying to do some concept work on this, I discovered a puzzle in the data! Many lines go in two opposite directions. Here in Trondheim, Line 3 goes from Loholt to Hallset, but also from Hallset to Loholt. The way I can tell these apart is to look up the direction in the data. Within a line, there can be variations in each direction. Some services might skip some stops, or depending on how you look at it, others visit extra stops. But these are variations on a theme, and it probably makes sense to group them together to preserve our sanity and not get 12 different plots for each line—2 should be plenty!"><meta property="og:type" content="article"><meta property="og:url" content="https://kaveland.no/posts/2025-05-28-turning-the-bus-sql/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-28T19:30:00+02:00"><meta property="article:modified_time" content="2025-05-28T19:30:00+02:00"><meta property="og:site_name" content="Robin's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Using SQL to turn all the buses around"><meta name=twitter:description content="I have a small hobby project over at kollektivkart.arktekk.no that is for visualizing changes in public transit in Norway. For some time I&rsquo;ve been wanting to do some visualizations on public transit lines. For example, plot the mean delay at each stop used by a line over time.
When trying to do some concept work on this, I discovered a puzzle in the data! Many lines go in two opposite directions. Here in Trondheim, Line 3 goes from Loholt to Hallset, but also from Hallset to Loholt. The way I can tell these apart is to look up the direction in the data. Within a line, there can be variations in each direction. Some services might skip some stops, or depending on how you look at it, others visit extra stops. But these are variations on a theme, and it probably makes sense to group them together to preserve our sanity and not get 12 different plots for each line—2 should be plenty!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kaveland.no/posts/"},{"@type":"ListItem","position":2,"name":"Using SQL to turn all the buses around","item":"https://kaveland.no/posts/2025-05-28-turning-the-bus-sql/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Using SQL to turn all the buses around","name":"Using SQL to turn all the buses around","description":"I have a small hobby project over at kollektivkart.arktekk.no that is for visualizing changes in public transit in Norway. For some time I\u0026rsquo;ve been wanting to do some visualizations on public transit lines. For example, plot the mean delay at each stop used by a line over time.\nWhen trying to do some concept work on this, I discovered a puzzle in the data! Many lines go in two opposite directions. Here in Trondheim, Line 3 goes from Loholt to Hallset, but also from Hallset to Loholt. The way I can tell these apart is to look up the direction in the data. Within a line, there can be variations in each direction. Some services might skip some stops, or depending on how you look at it, others visit extra stops. But these are variations on a theme, and it probably makes sense to group them together to preserve our sanity and not get 12 different plots for each line—2 should be plenty!\n","keywords":["data","sql","duckdb","seaborn","visualization"],"articleBody":"I have a small hobby project over at kollektivkart.arktekk.no that is for visualizing changes in public transit in Norway. For some time I’ve been wanting to do some visualizations on public transit lines. For example, plot the mean delay at each stop used by a line over time.\nWhen trying to do some concept work on this, I discovered a puzzle in the data! Many lines go in two opposite directions. Here in Trondheim, Line 3 goes from Loholt to Hallset, but also from Hallset to Loholt. The way I can tell these apart is to look up the direction in the data. Within a line, there can be variations in each direction. Some services might skip some stops, or depending on how you look at it, others visit extra stops. But these are variations on a theme, and it probably makes sense to group them together to preserve our sanity and not get 12 different plots for each line—2 should be plenty!\nThere’s just one problem. The direction information in the data is not stable over time. What was one day the “Inbound” direction, can suddenly become the “Outbound” direction! That’s to say, Hallset to Loholt might be Line 3 Outbound one day, then Inbound Line 3 the next. Oh no!\nI didn’t just happen to know that, by the way. I made the discovery when my plots weren’t making any sense. It turns out that I had assumed that this information would be stable over time, and I didn’t check the assumption. It’s always good to write down your assumptions and verify them when working with data analysis! Saves you from having to backtrack after having done tons of confusing work.\nAnyway, we have a problem in our data and want to check if we can face all the buses in the right direction again using SQL. I’ve done some setup and made the data public, so you can join in and try playing with the queries yourself. Maybe you’ll find a problem, bug or a better solution! Would love to hear from you at the repository if you do!\nSome setup is necessary. This is a jupyter notebook that is available here. It should run just fine if you install jupyter, duckdb, pyarrow and seaborn. You could use uv. You should get everything you need with this command:\nuv run --with jupyter --with duckdb --with seaborn --with jupysql jupyter lab We’ll be using data from Entur. This contains data for many years for all bus lanes in the Trondheim region (and many others). I’ve got a copy of this data going back to 2023 on my machine. But that’s a lot more than we need for this exercise, so I’ve done some preparation and made a smaller download we can use. I’ve collected the ATB (my regional public transit) data for 2024 on this address (~900MB download).\nI’ve done a bunch of cleanups on this data, like removing all the buses that were travelling exceedingly close to the speed of light. I’ve also connected each stop registration in the bus journey with the following stop registration, so we can look at driving durations on individual legs. The code for that is open source.\nWe’ll be using jupysql within this notebook, allowing us to use %sql in front of a line to send it to DuckDB, or %%sql to send an entire cell to DuckDB. We’ll do some plots with seaborn. Let’s load some data and get started!\nimport duckdb import seaborn as sns # Set up some styling for the visual stuff sns.set_theme( style='whitegrid', rc={ 'figure.figsize': (12, 8), 'figure.frameon': False, 'legend.frameon': False } ) db = duckdb.connect(':memory:') dataset_url = \"https://kaaveland-bus-eta-data.hel1.your-objectstorage.com/atb_legs.parquet\" %load_ext sql %config SqlMagic.displaylimit=50 %sql db --alias duckdb %sql set memory_limit='16GB'; %sql set threads=8; %sql create or replace table legs as from read_parquet('{{ dataset_url }}') Count 36214722 We’ve got some 36 million rows in memory now. Let’s start by looking at the schema we have:\n%sql describe legs; column_name column_type null key default extra lineRef VARCHAR YES None None None dataSource VARCHAR YES None None None directionRef VARCHAR YES None None None serviceJourneyId VARCHAR YES None None None sequenceNr BIGINT YES None None None start_time TIMESTAMP WITH TIME ZONE YES None None None actual_duration INTEGER YES None None None planned_duration INTEGER YES None None None delay INTEGER YES None None None deviation INTEGER YES None None None to_stop VARCHAR YES None None None from_stop VARCHAR YES None None None to_lat DOUBLE YES None None None to_lon DOUBLE YES None None None from_lat DOUBLE YES None None None from_lon DOUBLE YES None None None air_distance_meters INTEGER YES None None None operatingDate DATE YES None None None For now, these are the most interesting columns for us to focus on:\nlineRef is an identifier for a line. directionRef indicates which direction that this particular journey travels in. serviceJourneyId is an ID of a trip. With operatingDate, it uniquely identifies a journey. sequenceNr is a monotonically increasing number that increases at each stop point in the journey. Ours starts at 2, because we use the sequenceNr for the to_stop of a leg. from_stop and to_stop are two subsequent stop points in a journey. In theory, we can use lineRef and directionRef to identify the route of the journey. But I’ve been claiming that there’s a problem with directionRef.\nHouston, what exactly is the problem? I mentioned that I got some unexpected results when analyzing lines. I did a little bit of digging, and identified that the meaning of directionRef is not stable over time. Let’s take a look at what that means. The lineRef where I first identified this problem is 'ATB:Line:2_3', one of the lines that I frequently use to/from town. This should have 2 different directions. Let’s check:\n%%sql from legs select count(*) as count, directionRef where lineRef = 'ATB:Line:2_3' group by directionRef order by count desc; count directionRef 694901 Inbound 694815 Outbound At first glance, this looks fine. The data is about evenly distributed, as we’d expect. To illustrate the problem, let’s look at a leg on this line. Line 3 goes from Nidarosdomen to Studentersamfundet heading one way, and from Studentersamfundet to Nidarosdomen heading in the opposite direction. Let’s check which direction is which:\ndf = db.sql(\"\"\" from legs select count(*) as count, directionRef, date_trunc('month', operatingDate) as month where -- This selects for a single directionRef, right? Right? from_stop = 'Studentersamfundet' and to_stop = 'Nidarosdomen' and lineRef = 'ATB:Line:2_3' group by all order by month; \"\"\").df() sns.catplot(df, y='month', x='count', hue='directionRef', kind='bar'); Did you see that? They just turned the directions around! It’s easy to miss this kind of thing, but it happens all the time. Gathering data from the physical world is complex and difficult!\nIf we aggregate based on this, the meaning changes some time in the start of summer 2024. Using this for aggregations won’t make much sense. It’ll be like aggregating the phone book. We’ll get numbers, but will anyone pick up?\nSo, we need to find a way to fix this. Let’s zoom in a little bit on June 2024:\ndf = db.sql(\"\"\" from legs select count(*) as count, directionRef, operatingDate -- For me, this is _to_ town where from_stop = 'Studentersamfundet' and to_stop = 'Nidarosdomen' and lineRef = 'ATB:Line:2_3' and operatingDate between '2024-06-01' and '2024-06-10' group by all order by operatingDate; \"\"\").df() sns.catplot(df, y='operatingDate', x='count', hue='directionRef', kind='bar'); We can probably assume that directionRef is consistent within one day. This means that if we could build a mapping from lineRef, operatingDate to some “canonical” direction, we can handle this issue. That’s great news! Building that mapping is the topic of this analysis.\nA canonical what? Since the meaning of Inbound can change, we need some other way to name the direction. My intuition is that we can probably use the most common origin and the most common destination with that directionRef on that day. Hopefully, that stays stable across time. I guess we’ll find out!\nWe can easily use window functions to find the first and last stop of each serviceJourneyId, operatingDate pair. The way this works is that we define a window, which has two parts:\nA partition, or group key. The window function gets to look at every row within the same partition and do some sort of aggregation. We can also use a clause to bound the size of the window, and give it an ordering. Window functions are awesome! We get to do aggregations without having to throw away lots of rows, saving us lots of subqueries.\nLet’s do a small demo. First, let’s show all the data from one bus journey on line 3:\n%%sql with choice as ( from legs select operatingDate, serviceJourneyId where lineRef = 'ATB:Line:2_3' and operatingDate = '2024-01-01' limit 1 ) from choice join legs using(operatingDate, serviceJourneyId) select directionRef, sequenceNr, start_time, from_stop, to_stop order by sequenceNr; directionRef sequenceNr start_time from_stop to_stop Inbound 2 2024-01-01 15:48:26+01:00 Dragvoll Edvard Bulls veg Inbound 3 2024-01-01 15:49:19+01:00 Edvard Bulls veg Bergheim Inbound 4 2024-01-01 15:50:37+01:00 Bergheim Voll studentby Inbound 5 2024-01-01 15:53:49+01:00 Voll studentby Moholt studentby Inbound 6 2024-01-01 15:55:11+01:00 Moholt studentby Østre Berg Inbound 7 2024-01-01 15:56:17+01:00 Østre Berg Berg studentby Inbound 8 2024-01-01 15:58:10+01:00 Berg studentby Gløshaugen Inbound 9 2024-01-01 15:59:57+01:00 Gløshaugen Høgskoleringen Inbound 10 2024-01-01 16:01:18+01:00 Høgskoleringen Studentersamfundet Inbound 11 2024-01-01 16:02:38+01:00 Studentersamfundet Nidarosdomen Inbound 12 2024-01-01 16:03:52+01:00 Nidarosdomen Kongens gate Inbound 13 2024-01-01 16:05:29+01:00 Kongens gate Hospitalskirka Inbound 14 2024-01-01 16:07:02+01:00 Hospitalskirka Skansen Inbound 15 2024-01-01 16:08:50+01:00 Skansen Nyveibakken Inbound 16 2024-01-01 16:11:09+01:00 Nyveibakken Tvetestien Inbound 17 2024-01-01 16:12:20+01:00 Tvetestien Åsveien skole Inbound 18 2024-01-01 16:13:04+01:00 Åsveien skole Johan Falkbergets vei Inbound 19 2024-01-01 16:14:11+01:00 Johan Falkbergets vei Havstadsenteret Inbound 20 2024-01-01 16:15:09+01:00 Havstadsenteret Stabells veg Inbound 21 2024-01-01 16:16:45+01:00 Stabells veg Byåsen skole Inbound 22 2024-01-01 16:18:08+01:00 Byåsen skole Hallset We can tell that the origin is Dragvoll and the destination is Hallset. We can easily put that information on each row using a window function. Look ma, no group by!\n%%sql with choice as ( from legs select operatingDate, serviceJourneyId where lineRef = 'ATB:Line:2_3' and operatingDate = '2024-01-01' limit 1 ) from choice join legs using(operatingDate, serviceJourneyId) select -- this is old directionRef, sequenceNr, start_time, from_stop, to_stop, -- new column, window function! min_by(from_stop, sequenceNr) over ( partition by (operatingDate, serviceJourneyId) ) as origin, -- also a window function max_by(to_stop, sequenceNr) over ( partition by (operatingDate, serviceJourneyId) ) as destination order by sequenceNr; directionRef sequenceNr start_time from_stop to_stop origin destination Inbound 2 2024-01-01 15:48:26+01:00 Dragvoll Edvard Bulls veg Dragvoll Hallset Inbound 3 2024-01-01 15:49:19+01:00 Edvard Bulls veg Bergheim Dragvoll Hallset Inbound 4 2024-01-01 15:50:37+01:00 Bergheim Voll studentby Dragvoll Hallset Inbound 5 2024-01-01 15:53:49+01:00 Voll studentby Moholt studentby Dragvoll Hallset Inbound 6 2024-01-01 15:55:11+01:00 Moholt studentby Østre Berg Dragvoll Hallset Inbound 7 2024-01-01 15:56:17+01:00 Østre Berg Berg studentby Dragvoll Hallset Inbound 8 2024-01-01 15:58:10+01:00 Berg studentby Gløshaugen Dragvoll Hallset Inbound 9 2024-01-01 15:59:57+01:00 Gløshaugen Høgskoleringen Dragvoll Hallset Inbound 10 2024-01-01 16:01:18+01:00 Høgskoleringen Studentersamfundet Dragvoll Hallset Inbound 11 2024-01-01 16:02:38+01:00 Studentersamfundet Nidarosdomen Dragvoll Hallset Inbound 12 2024-01-01 16:03:52+01:00 Nidarosdomen Kongens gate Dragvoll Hallset Inbound 13 2024-01-01 16:05:29+01:00 Kongens gate Hospitalskirka Dragvoll Hallset Inbound 14 2024-01-01 16:07:02+01:00 Hospitalskirka Skansen Dragvoll Hallset Inbound 15 2024-01-01 16:08:50+01:00 Skansen Nyveibakken Dragvoll Hallset Inbound 16 2024-01-01 16:11:09+01:00 Nyveibakken Tvetestien Dragvoll Hallset Inbound 17 2024-01-01 16:12:20+01:00 Tvetestien Åsveien skole Dragvoll Hallset Inbound 18 2024-01-01 16:13:04+01:00 Åsveien skole Johan Falkbergets vei Dragvoll Hallset Inbound 19 2024-01-01 16:14:11+01:00 Johan Falkbergets vei Havstadsenteret Dragvoll Hallset Inbound 20 2024-01-01 16:15:09+01:00 Havstadsenteret Stabells veg Dragvoll Hallset Inbound 21 2024-01-01 16:16:45+01:00 Stabells veg Byåsen skole Dragvoll Hallset Inbound 22 2024-01-01 16:18:08+01:00 Byåsen skole Hallset Dragvoll Hallset So that’s pretty neat!\nWe don’t really need window functions for this, we can do this with group by. But knowing about window functions will come in handy later!\nIn DuckDB, we have a qualify clause that we can put after where, which allows us to filter a row based on a window function. We can’t use where to filter on the result of a window function, because where is necessary in order find out which rows that are part of the window. The result of the window function can’t be known until after where has run! Many SQL dialects now support qualify, which is a super handy quality of life change. Without it, we would need to use a subquery or CTE.\nLet’s make a table that maps from operatingDate, lineRef, directionRef to the most commonly used origin and destination pair for that combination.\n%%sql create or replace table route_name as with counts as ( from legs select -- This is the triple we want to name / map operatingDate, lineRef, directionRef, -- These are what we'll use for naming. Maybe they're stable over time? min_by(from_stop, sequenceNr) as origin, max_by(to_stop, sequenceNr) as destination, -- We'll use this to rank them, picking the most common pair of origin/destination -- as the name for the `directionRef` on this day count(*) as count group by all -- handy shortcut to group by whatever we didn't aggregate ) from counts select operatingDate, lineRef, directionRef, origin, destination, count qualify count = max(count) over (partition by (operatingDate, lineRef, directionRef)); Count 149176 Let’s zoom in on June 2024 again, and check if this fixes our problem:\ndf = db.sql(\"\"\" from legs join route_name using(operatingDate, directionRef, lineRef) select count(*) as count, directionRef, operatingDate, origin || ' to ' || destination as route_name where ((from_stop = 'Studentersamfundet' and to_stop = 'Nidarosdomen') or (from_stop = 'Nidarosdomen' and to_stop = 'Studentersamfundet')) and (lineRef = 'ATB:Line:2_3' and operatingDate between '2024-06-01' and '2024-06-10') group by all order by operatingDate; \"\"\").df() sns.catplot( df, y='operatingDate', x='count', hue='directionRef', col='route_name', kind='bar' ); Huge success! These stay stable even when the meaning of directionRef changes. Now let’s zoom back out:\ndf = db.sql(\"\"\" from legs join route_name using(operatingDate, directionRef, lineRef) select count(*) as count, directionRef, date_trunc('month', operatingDate) as month, origin || ' to ' || destination as route_name where ((from_stop = 'Studentersamfundet' and to_stop = 'Nidarosdomen') or (from_stop = 'Nidarosdomen' and to_stop = 'Studentersamfundet')) and lineRef = 'ATB:Line:2_3' group by all order by month; \"\"\").df() sns.catplot( df, y='operatingDate', x='count', hue='directionRef', col='route_name', kind='bar' ); This appears to be stable all year. Great news! We’re not entirely home-free, though.\nLet me show you what I mean by sampling another lineRef:\ndf = db.sql(\"\"\" from legs join route_name using(operatingDate, directionRef, lineRef) select count(*) as count, directionRef, date_trunc('month', operatingDate) as month, origin || ' to ' || destination as route_name where ((from_stop = 'Studentersamfundet' and to_stop = 'Nidarosdomen') or (from_stop = 'Nidarosdomen' and to_stop = 'Studentersamfundet')) and lineRef = 'ATB:Line:2_1') group by all order by month; \"\"\").df() sns.catplot( df, y='operatingDate', x='count', hue='directionRef', col='route_name', kind='bar' ); Huge disappointment! Oh no, this one has more variations!\nFortunately, we can fix this too! Perhaps not perfectly, but something that should be close enough.\nWhat should be sufficient is to set a permanent directionRef for each route name. We’ll use the first directionRef we ever observed for that route. This is just a minor tweak to our route_name table from above:\n%%sql create or replace table route_name as with counts as ( from legs select operatingDate, lineRef, directionRef, min_by(from_stop, sequenceNr) as origin, max_by(to_stop, sequenceNr) as destination, count(*) as count group by all ) from counts select operatingDate, lineRef, directionRef, -- Changed this! We'll propagate the first directionRef seen -- for this line/origin/destination to all of eternity min_by(directionRef, operatingDate) over ( partition by (lineRef, origin, destination) ) as canonical_direction, origin, destination, count qualify count = max(count) over (partition by (operatingDate, lineRef, directionRef)) Count 149176 Did we conquer line 1 now? Let’s check whether we can use the new canonical_direction to separate these now:\ndf = db.sql(\"\"\" from legs join route_name using(operatingDate, directionRef, lineRef) select count(*) as count, date_trunc('month', operatingDate) as month, canonical_direction, origin || ' to ' || destination as route_name where ((from_stop = 'Studentersamfundet' and to_stop = 'Nidarosdomen') or (from_stop = 'Nidarosdomen' and to_stop = 'Studentersamfundet')) and lineRef = 'ATB:Line:2_1' group by all order by month; \"\"\").df() sns.catplot( df, y='month', x='count', hue='canonical_direction', col='route_name', kind='bar' ); Looks pretty good! This seems to fix our main problem. This notebook wouldn’t be complete without taking a look at what kind of difference this makes, though. Let’s do some shallow plotting so we can compare the mean delay at the latest stop in each journey by directionRef, and by canonical_direction.\ndf = db.sql(\"\"\" with journey_delay as ( from legs select operatingDate, serviceJourneyId, directionRef, lineRef, max_by(delay, sequenceNr) as delay where operatingDate between '2024-04-15' and '2024-10-15' group by all ), regular as ( select operatingDate, quantile_disc(delay, .75) as delay, directionRef, 'directionRef' as kind from journey_delay where lineRef = 'ATB:Line:2_3' group by all order by operatingDate, directionRef ), canonical as ( select operatingDate, quantile_disc(delay, .75) as delay, route_name.canonical_direction as directionRef, 'canonical' as kind from journey_delay join route_name using(operatingDate, lineRef, directionRef) where lineRef = 'ATB:Line:2_3' group by all order by operatingDate, directionRef ) select * from regular union all select * from canonical \"\"\").df() sns.relplot( df, x='operatingDate', y='delay', hue='kind', col='directionRef', kind='line' ); Makes a difference! I’ll make a job that keeps something like the route_name table up to date so that I can keep track of the “true” direction of a line for my analysis. Should be fun to see if this works with all ~500 million legs in the main data set! I’m sure it’ll be fine; DuckDB chews through this notebook in just a few seconds after the initial download is done.\nThanks for reading!\n","wordCount":"2894","inLanguage":"en","datePublished":"2025-05-28T19:30:00+02:00","dateModified":"2025-05-28T19:30:00+02:00","author":{"@type":"Person","name":"Robin Kåveland"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kaveland.no/posts/2025-05-28-turning-the-bus-sql/"},"publisher":{"@type":"Organization","name":"Robin's blog","logo":{"@type":"ImageObject","url":"https://kaveland.no/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kaveland.no/ accesskey=h title="Robin's blog (Alt + H)">Robin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kaveland.no/about/ title=about><span>about</span></a></li><li><a href=https://kaveland.no/projects/ title=projects><span>projects</span></a></li><li><a href=https://kaveland.no/eugene/ title=eugene><span>eugene</span></a></li><li><a href=https://kaveland.no/thumper/ title=thumper><span>thumper</span></a></li><li><a href=https://kaveland.no/tags/ title=tags><span>tags</span></a></li><li><a href=https://kaveland.no/archives/ title=archives><span>archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kaveland.no/>Home</a>&nbsp;»&nbsp;<a href=https://kaveland.no/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Using SQL to turn all the buses around</h1><div class=post-meta><span title='2025-05-28 19:30:00 +0200 CEST'>May 28, 2025</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;2894 words&nbsp;·&nbsp;Robin Kåveland&nbsp;|&nbsp;<a href=https://github.com/kaaveland/kaaveland.github.io/content/posts/2025-05-28-turning-the-bus-sql/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#houston-what-exactly-is-the-problem>Houston, what exactly is the problem?</a></li><li><a href=#a-canonical-what>A canonical what?</a></li><li><a href=#huge-success>Huge success!</a></li><li><a href=#huge-disappointment>Huge disappointment!</a></li><li><a href=#did-we-conquer-line-1-now>Did we conquer line 1 now?</a></li><li><a href=#looks-pretty-good>Looks pretty good!</a></li></ul></nav></div></details></div><div class=post-content><p>I have a small hobby project over at <a href=https://kollektivkart.arktekk.no/>kollektivkart.arktekk.no</a> that is for visualizing changes in public transit in Norway. For some time I&rsquo;ve been wanting to do some visualizations on public transit lines. For example, plot the mean delay at each stop used by a line over time.</p><p>When trying to do some concept work on this, I discovered a puzzle in the data! Many lines go in two opposite directions. Here in Trondheim, Line 3 goes from Loholt to Hallset, but also from Hallset to Loholt. The way I can tell these apart is to look up the <em>direction</em> in the data. Within a line, there can be variations in each direction. Some services might skip some stops, or depending on how you look at it, others visit extra stops. But these are variations on a theme, and it probably makes sense to group them together to preserve our sanity and not get 12 different plots for each line—2 should be plenty!</p><p>There&rsquo;s just one problem. The <em>direction</em> information in the data is not stable over time. What was one day the &ldquo;Inbound&rdquo; direction, can suddenly become the &ldquo;Outbound&rdquo; direction! That&rsquo;s to say, Hallset to Loholt might be Line 3 Outbound one day, then Inbound Line 3 the next. Oh no!</p><p>I didn&rsquo;t just happen to <em>know</em> that, by the way. I made the discovery when my plots weren&rsquo;t making any sense. It turns out that I had assumed that this information would be stable over time, and I didn&rsquo;t check the assumption. It&rsquo;s always good to write down your assumptions and verify them when working with data analysis! Saves you from having to backtrack after having done tons of confusing work.</p><p>Anyway, we have a problem in our data and want to check if we can face all the buses in the right direction again using SQL. I&rsquo;ve done some setup and made the data public, so you can join in and try playing with the queries yourself. Maybe you&rsquo;ll find a problem, bug or a better solution! Would love to hear from you at the <a href=https://github.com/kaaveland/bus-eta>repository</a> if you do!</p><p>Some setup is necessary. This is a jupyter notebook that is available <a href=https://github.com/kaaveland/bus-eta/blob/main/notebooks/LinesEDA.ipynb>here</a>. It should run just fine if you install jupyter, duckdb, pyarrow and seaborn. You could use <a href=https://docs.astral.sh/uv/>uv</a>. You should get everything you need with this command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>uv run --with jupyter --with duckdb --with seaborn --with jupysql jupyter lab
</span></span></code></pre></div><p>We&rsquo;ll be using data from <a href=https://data.entur.no/domain/public-transport-data>Entur</a>. This contains data for many years for all bus lanes in the Trondheim region (and many others). I&rsquo;ve got a copy of this data going back to 2023 on my machine. But that&rsquo;s a lot more than we need for this exercise, so I&rsquo;ve done some preparation and made a smaller download we can use. I&rsquo;ve collected the ATB (my regional public transit) data for 2024 on <a href=https://kaaveland-bus-eta-data.hel1.your-objectstorage.com/atb_legs.parquet>this address</a> (~900MB download).</p><p>I&rsquo;ve done a bunch of cleanups on this data, like removing all the buses that were travelling exceedingly close to the speed of light. I&rsquo;ve also connected each stop registration in the bus journey with the following stop registration, so we can look at driving durations on individual legs. The <a href=https://github.com/kaaveland/bus-eta/blob/main/kollektivkart/etl/legs.py>code</a> for that is open source.</p><p>We&rsquo;ll be using <a href=https://jupysql.ploomber.io/en/latest/quick-start.html>jupysql</a> within this notebook, allowing us to use <code>%sql</code> in front of a line to send it to DuckDB, or <code>%%sql</code> to send an entire cell to DuckDB. We&rsquo;ll do some plots with <a href=https://seaborn.pydata.org/>seaborn</a>. Let&rsquo;s load some data and get started!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>duckdb</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>seaborn</span> <span class=k>as</span> <span class=nn>sns</span>
</span></span><span class=line><span class=cl><span class=c1># Set up some styling for the visual stuff</span>
</span></span><span class=line><span class=cl><span class=n>sns</span><span class=o>.</span><span class=n>set_theme</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>style</span><span class=o>=</span><span class=s1>&#39;whitegrid&#39;</span><span class=p>,</span> <span class=n>rc</span><span class=o>=</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;figure.figsize&#39;</span><span class=p>:</span> <span class=p>(</span><span class=mi>12</span><span class=p>,</span> <span class=mi>8</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;figure.frameon&#39;</span><span class=p>:</span> <span class=kc>False</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;legend.frameon&#39;</span><span class=p>:</span> <span class=kc>False</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>db</span> <span class=o>=</span> <span class=n>duckdb</span><span class=o>.</span><span class=n>connect</span><span class=p>(</span><span class=s1>&#39;:memory:&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>dataset_url</span> <span class=o>=</span> <span class=s2>&#34;https://kaaveland-bus-eta-data.hel1.your-objectstorage.com/atb_legs.parquet&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=n>load_ext</span> <span class=n>sql</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=n>config</span> <span class=n>SqlMagic</span><span class=o>.</span><span class=n>displaylimit</span><span class=o>=</span><span class=mi>50</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=n>sql</span> <span class=n>db</span> <span class=o>--</span><span class=n>alias</span> <span class=n>duckdb</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=n>sql</span> <span class=nb>set</span> <span class=n>memory_limit</span><span class=o>=</span><span class=s1>&#39;16GB&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=n>sql</span> <span class=nb>set</span> <span class=n>threads</span><span class=o>=</span><span class=mi>8</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=n>sql</span> <span class=n>create</span> <span class=ow>or</span> <span class=n>replace</span> <span class=n>table</span> <span class=n>legs</span> <span class=k>as</span> <span class=kn>from</span> <span class=nn>read_parquet</span><span class=p>(</span><span class=s1>&#39;{{ dataset_url }}&#39;</span><span class=p>)</span>
</span></span></code></pre></div><table><thead><tr><th>Count</th></tr></thead><tbody><tr><td>36214722</td></tr></tbody></table><p>We&rsquo;ve got some 36 million rows in memory now. Let&rsquo;s start by looking at the schema we have:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>%</span><span class=k>sql</span><span class=w> </span><span class=k>describe</span><span class=w> </span><span class=n>legs</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><table><thead><tr><th>column_name</th><th>column_type</th><th>null</th><th>key</th><th>default</th><th>extra</th></tr></thead><tbody><tr><td>lineRef</td><td>VARCHAR</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>dataSource</td><td>VARCHAR</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>directionRef</td><td>VARCHAR</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>serviceJourneyId</td><td>VARCHAR</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>sequenceNr</td><td>BIGINT</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>start_time</td><td>TIMESTAMP WITH TIME ZONE</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>actual_duration</td><td>INTEGER</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>planned_duration</td><td>INTEGER</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>delay</td><td>INTEGER</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>deviation</td><td>INTEGER</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>to_stop</td><td>VARCHAR</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>from_stop</td><td>VARCHAR</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>to_lat</td><td>DOUBLE</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>to_lon</td><td>DOUBLE</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>from_lat</td><td>DOUBLE</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>from_lon</td><td>DOUBLE</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>air_distance_meters</td><td>INTEGER</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr><tr><td>operatingDate</td><td>DATE</td><td>YES</td><td>None</td><td>None</td><td>None</td></tr></tbody></table><p>For now, these are the most interesting columns for us to focus on:</p><ul><li><code>lineRef</code> is an identifier for a line.</li><li><code>directionRef</code> indicates which direction that this particular journey travels in.</li><li><code>serviceJourneyId</code> is an ID of a trip. With <code>operatingDate</code>, it uniquely identifies a journey.</li><li><code>sequenceNr</code> is a monotonically increasing number that increases at each stop point in the journey. Ours starts at <code>2</code>, because we use the <code>sequenceNr</code> for the <code>to_stop</code> of a leg.</li><li><code>from_stop</code> and <code>to_stop</code> are two subsequent stop points in a journey.</li></ul><p>In theory, we can use <code>lineRef</code> and <code>directionRef</code> to identify the route of the journey. But I&rsquo;ve been claiming that there&rsquo;s a problem with <code>directionRef</code>.</p><h2 id=houston-what-exactly-is-the-problem>Houston, what exactly is the problem?<a hidden class=anchor aria-hidden=true href=#houston-what-exactly-is-the-problem>#</a></h2><p>I mentioned that I got some unexpected results when analyzing lines. I did a little bit of digging, and identified that the <em>meaning</em> of <code>directionRef</code> is not stable over time. Let&rsquo;s take a look at what that means. The <code>lineRef</code> where I first identified this problem is <code>'ATB:Line:2_3'</code>, one of the lines that I frequently use to/from town. This should have 2 different directions. Let&rsquo;s check:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>%%</span><span class=k>sql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>from</span><span class=w> </span><span class=n>legs</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=k>count</span><span class=p>,</span><span class=w> </span><span class=n>directionRef</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w> </span><span class=n>lineRef</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;ATB:Line:2_3&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>directionRef</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=k>count</span><span class=w> </span><span class=k>desc</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><table><thead><tr><th>count</th><th>directionRef</th></tr></thead><tbody><tr><td>694901</td><td>Inbound</td></tr><tr><td>694815</td><td>Outbound</td></tr></tbody></table><p>At first glance, this looks fine. The data is about evenly distributed, as we&rsquo;d expect. To illustrate the problem, let&rsquo;s look at a leg on this line. Line 3 goes from Nidarosdomen to Studentersamfundet heading one way, and from Studentersamfundet to Nidarosdomen heading in the opposite direction. Let&rsquo;s check which direction is which:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>df</span> <span class=o>=</span> <span class=n>db</span><span class=o>.</span><span class=n>sql</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>from legs
</span></span></span><span class=line><span class=cl><span class=s2>select count(*) as count, directionRef, date_trunc(&#39;month&#39;, operatingDate) as month
</span></span></span><span class=line><span class=cl><span class=s2>where
</span></span></span><span class=line><span class=cl><span class=s2>  -- This selects for a single directionRef, right? Right?
</span></span></span><span class=line><span class=cl><span class=s2>  from_stop = &#39;Studentersamfundet&#39; and to_stop = &#39;Nidarosdomen&#39;
</span></span></span><span class=line><span class=cl><span class=s2>  and lineRef = &#39;ATB:Line:2_3&#39;
</span></span></span><span class=line><span class=cl><span class=s2>group by all
</span></span></span><span class=line><span class=cl><span class=s2>order by month;
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>df</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sns</span><span class=o>.</span><span class=n>catplot</span><span class=p>(</span><span class=n>df</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=s1>&#39;month&#39;</span><span class=p>,</span> <span class=n>x</span><span class=o>=</span><span class=s1>&#39;count&#39;</span><span class=p>,</span> <span class=n>hue</span><span class=o>=</span><span class=s1>&#39;directionRef&#39;</span><span class=p>,</span> <span class=n>kind</span><span class=o>=</span><span class=s1>&#39;bar&#39;</span><span class=p>);</span>
</span></span></code></pre></div><img src=/posts/2025-05-28-turning-the-bus-sql/LinesEDA_7_0.png alt=plot><p>Did you see that? They just turned the directions around! It&rsquo;s easy to miss this kind of thing, but it happens all the time. Gathering data from the physical world is complex and difficult!</p><p>If we aggregate based on this, the meaning changes some time in the start of summer 2024. Using this for aggregations won&rsquo;t make much sense. It&rsquo;ll be like aggregating the phone book. We&rsquo;ll get numbers, but will anyone pick up?</p><p>So, we need to find a way to fix this. Let&rsquo;s zoom in a little bit on June 2024:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>df</span> <span class=o>=</span> <span class=n>db</span><span class=o>.</span><span class=n>sql</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>from legs
</span></span></span><span class=line><span class=cl><span class=s2>select count(*) as count, directionRef, operatingDate
</span></span></span><span class=line><span class=cl><span class=s2>-- For me, this is _to_ town
</span></span></span><span class=line><span class=cl><span class=s2>where
</span></span></span><span class=line><span class=cl><span class=s2>  from_stop = &#39;Studentersamfundet&#39;
</span></span></span><span class=line><span class=cl><span class=s2>  and to_stop = &#39;Nidarosdomen&#39;
</span></span></span><span class=line><span class=cl><span class=s2>  and lineRef = &#39;ATB:Line:2_3&#39;
</span></span></span><span class=line><span class=cl><span class=s2>  and operatingDate between &#39;2024-06-01&#39; and &#39;2024-06-10&#39;
</span></span></span><span class=line><span class=cl><span class=s2>group by all
</span></span></span><span class=line><span class=cl><span class=s2>order by operatingDate;
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>df</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sns</span><span class=o>.</span><span class=n>catplot</span><span class=p>(</span><span class=n>df</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=s1>&#39;operatingDate&#39;</span><span class=p>,</span> <span class=n>x</span><span class=o>=</span><span class=s1>&#39;count&#39;</span><span class=p>,</span> <span class=n>hue</span><span class=o>=</span><span class=s1>&#39;directionRef&#39;</span><span class=p>,</span> <span class=n>kind</span><span class=o>=</span><span class=s1>&#39;bar&#39;</span><span class=p>);</span>
</span></span></code></pre></div><img src=/posts/2025-05-28-turning-the-bus-sql/LinesEDA_9_0.png alt=plot><p>We can probably assume that <code>directionRef</code> is consistent within one day. This means that if we could build a mapping from <code>lineRef, operatingDate</code> to some &ldquo;canonical&rdquo; direction, we can handle this issue. That&rsquo;s great news! Building that mapping is the topic of this analysis.</p><h2 id=a-canonical-what>A canonical what?<a hidden class=anchor aria-hidden=true href=#a-canonical-what>#</a></h2><p>Since the meaning of <code>Inbound</code> can change, we need some other way to name the direction. My intuition is that we can probably use the most common origin and the most common destination with that <code>directionRef</code> on that day. Hopefully, that stays stable across time. I guess we&rsquo;ll find out!</p><p>We can easily use window functions to find the first and last stop of each <code>serviceJourneyId, operatingDate</code> pair. The way this works is that we define a window, which has two parts:</p><ul><li>A partition, or group key. The window function gets to look at every row within the same partition and do some sort of aggregation.</li><li>We can also use a clause to bound the size of the window, and give it an ordering.</li></ul><p>Window functions are awesome! We get to do aggregations without having to throw away lots of rows, saving us lots of subqueries.</p><p>Let&rsquo;s do a small demo. First, let&rsquo;s show all the data from one bus journey on line 3:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>%%</span><span class=k>sql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>with</span><span class=w> </span><span class=n>choice</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>from</span><span class=w> </span><span class=n>legs</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>select</span><span class=w> </span><span class=n>operatingDate</span><span class=p>,</span><span class=w> </span><span class=n>serviceJourneyId</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>lineRef</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;ATB:Line:2_3&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>operatingDate</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;2024-01-01&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>limit</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>from</span><span class=w> </span><span class=n>choice</span><span class=w> </span><span class=k>join</span><span class=w> </span><span class=n>legs</span><span class=w> </span><span class=k>using</span><span class=p>(</span><span class=n>operatingDate</span><span class=p>,</span><span class=w> </span><span class=n>serviceJourneyId</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=n>directionRef</span><span class=p>,</span><span class=w> </span><span class=n>sequenceNr</span><span class=p>,</span><span class=w> </span><span class=n>start_time</span><span class=p>,</span><span class=w> </span><span class=n>from_stop</span><span class=p>,</span><span class=w> </span><span class=n>to_stop</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>sequenceNr</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><table><thead><tr><th>directionRef</th><th>sequenceNr</th><th>start_time</th><th>from_stop</th><th>to_stop</th></tr></thead><tbody><tr><td>Inbound</td><td>2</td><td>2024-01-01 15:48:26+01:00</td><td>Dragvoll</td><td>Edvard Bulls veg</td></tr><tr><td>Inbound</td><td>3</td><td>2024-01-01 15:49:19+01:00</td><td>Edvard Bulls veg</td><td>Bergheim</td></tr><tr><td>Inbound</td><td>4</td><td>2024-01-01 15:50:37+01:00</td><td>Bergheim</td><td>Voll studentby</td></tr><tr><td>Inbound</td><td>5</td><td>2024-01-01 15:53:49+01:00</td><td>Voll studentby</td><td>Moholt studentby</td></tr><tr><td>Inbound</td><td>6</td><td>2024-01-01 15:55:11+01:00</td><td>Moholt studentby</td><td>Østre Berg</td></tr><tr><td>Inbound</td><td>7</td><td>2024-01-01 15:56:17+01:00</td><td>Østre Berg</td><td>Berg studentby</td></tr><tr><td>Inbound</td><td>8</td><td>2024-01-01 15:58:10+01:00</td><td>Berg studentby</td><td>Gløshaugen</td></tr><tr><td>Inbound</td><td>9</td><td>2024-01-01 15:59:57+01:00</td><td>Gløshaugen</td><td>Høgskoleringen</td></tr><tr><td>Inbound</td><td>10</td><td>2024-01-01 16:01:18+01:00</td><td>Høgskoleringen</td><td>Studentersamfundet</td></tr><tr><td>Inbound</td><td>11</td><td>2024-01-01 16:02:38+01:00</td><td>Studentersamfundet</td><td>Nidarosdomen</td></tr><tr><td>Inbound</td><td>12</td><td>2024-01-01 16:03:52+01:00</td><td>Nidarosdomen</td><td>Kongens gate</td></tr><tr><td>Inbound</td><td>13</td><td>2024-01-01 16:05:29+01:00</td><td>Kongens gate</td><td>Hospitalskirka</td></tr><tr><td>Inbound</td><td>14</td><td>2024-01-01 16:07:02+01:00</td><td>Hospitalskirka</td><td>Skansen</td></tr><tr><td>Inbound</td><td>15</td><td>2024-01-01 16:08:50+01:00</td><td>Skansen</td><td>Nyveibakken</td></tr><tr><td>Inbound</td><td>16</td><td>2024-01-01 16:11:09+01:00</td><td>Nyveibakken</td><td>Tvetestien</td></tr><tr><td>Inbound</td><td>17</td><td>2024-01-01 16:12:20+01:00</td><td>Tvetestien</td><td>Åsveien skole</td></tr><tr><td>Inbound</td><td>18</td><td>2024-01-01 16:13:04+01:00</td><td>Åsveien skole</td><td>Johan Falkbergets vei</td></tr><tr><td>Inbound</td><td>19</td><td>2024-01-01 16:14:11+01:00</td><td>Johan Falkbergets vei</td><td>Havstadsenteret</td></tr><tr><td>Inbound</td><td>20</td><td>2024-01-01 16:15:09+01:00</td><td>Havstadsenteret</td><td>Stabells veg</td></tr><tr><td>Inbound</td><td>21</td><td>2024-01-01 16:16:45+01:00</td><td>Stabells veg</td><td>Byåsen skole</td></tr><tr><td>Inbound</td><td>22</td><td>2024-01-01 16:18:08+01:00</td><td>Byåsen skole</td><td>Hallset</td></tr></tbody></table><p>We can tell that the origin is Dragvoll and the destination is Hallset. We can easily put that information on each row using a window function. Look ma, no <code>group by</code>!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>%%</span><span class=k>sql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>with</span><span class=w> </span><span class=n>choice</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>from</span><span class=w> </span><span class=n>legs</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>select</span><span class=w> </span><span class=n>operatingDate</span><span class=p>,</span><span class=w> </span><span class=n>serviceJourneyId</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>where</span><span class=w> </span><span class=n>lineRef</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;ATB:Line:2_3&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>operatingDate</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;2024-01-01&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>limit</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>from</span><span class=w> </span><span class=n>choice</span><span class=w> </span><span class=k>join</span><span class=w> </span><span class=n>legs</span><span class=w> </span><span class=k>using</span><span class=p>(</span><span class=n>operatingDate</span><span class=p>,</span><span class=w> </span><span class=n>serviceJourneyId</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>-- this is old
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=n>directionRef</span><span class=p>,</span><span class=w> </span><span class=n>sequenceNr</span><span class=p>,</span><span class=w> </span><span class=n>start_time</span><span class=p>,</span><span class=w> </span><span class=n>from_stop</span><span class=p>,</span><span class=w> </span><span class=n>to_stop</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>-- new column, window function!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=n>min_by</span><span class=p>(</span><span class=n>from_stop</span><span class=p>,</span><span class=w> </span><span class=n>sequenceNr</span><span class=p>)</span><span class=w> </span><span class=n>over</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>partition</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=p>(</span><span class=n>operatingDate</span><span class=p>,</span><span class=w> </span><span class=n>serviceJourneyId</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>origin</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>-- also a window function
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=n>max_by</span><span class=p>(</span><span class=n>to_stop</span><span class=p>,</span><span class=w> </span><span class=n>sequenceNr</span><span class=p>)</span><span class=w> </span><span class=n>over</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>partition</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=p>(</span><span class=n>operatingDate</span><span class=p>,</span><span class=w> </span><span class=n>serviceJourneyId</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>destination</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>order</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=n>sequenceNr</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><table><thead><tr><th>directionRef</th><th>sequenceNr</th><th>start_time</th><th>from_stop</th><th>to_stop</th><th>origin</th><th>destination</th></tr></thead><tbody><tr><td>Inbound</td><td>2</td><td>2024-01-01 15:48:26+01:00</td><td>Dragvoll</td><td>Edvard Bulls veg</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>3</td><td>2024-01-01 15:49:19+01:00</td><td>Edvard Bulls veg</td><td>Bergheim</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>4</td><td>2024-01-01 15:50:37+01:00</td><td>Bergheim</td><td>Voll studentby</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>5</td><td>2024-01-01 15:53:49+01:00</td><td>Voll studentby</td><td>Moholt studentby</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>6</td><td>2024-01-01 15:55:11+01:00</td><td>Moholt studentby</td><td>Østre Berg</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>7</td><td>2024-01-01 15:56:17+01:00</td><td>Østre Berg</td><td>Berg studentby</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>8</td><td>2024-01-01 15:58:10+01:00</td><td>Berg studentby</td><td>Gløshaugen</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>9</td><td>2024-01-01 15:59:57+01:00</td><td>Gløshaugen</td><td>Høgskoleringen</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>10</td><td>2024-01-01 16:01:18+01:00</td><td>Høgskoleringen</td><td>Studentersamfundet</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>11</td><td>2024-01-01 16:02:38+01:00</td><td>Studentersamfundet</td><td>Nidarosdomen</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>12</td><td>2024-01-01 16:03:52+01:00</td><td>Nidarosdomen</td><td>Kongens gate</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>13</td><td>2024-01-01 16:05:29+01:00</td><td>Kongens gate</td><td>Hospitalskirka</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>14</td><td>2024-01-01 16:07:02+01:00</td><td>Hospitalskirka</td><td>Skansen</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>15</td><td>2024-01-01 16:08:50+01:00</td><td>Skansen</td><td>Nyveibakken</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>16</td><td>2024-01-01 16:11:09+01:00</td><td>Nyveibakken</td><td>Tvetestien</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>17</td><td>2024-01-01 16:12:20+01:00</td><td>Tvetestien</td><td>Åsveien skole</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>18</td><td>2024-01-01 16:13:04+01:00</td><td>Åsveien skole</td><td>Johan Falkbergets vei</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>19</td><td>2024-01-01 16:14:11+01:00</td><td>Johan Falkbergets vei</td><td>Havstadsenteret</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>20</td><td>2024-01-01 16:15:09+01:00</td><td>Havstadsenteret</td><td>Stabells veg</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>21</td><td>2024-01-01 16:16:45+01:00</td><td>Stabells veg</td><td>Byåsen skole</td><td>Dragvoll</td><td>Hallset</td></tr><tr><td>Inbound</td><td>22</td><td>2024-01-01 16:18:08+01:00</td><td>Byåsen skole</td><td>Hallset</td><td>Dragvoll</td><td>Hallset</td></tr></tbody></table><p>So that&rsquo;s pretty neat!</p><p>We don&rsquo;t really need window functions for this, we can do this with <code>group by</code>. But knowing about window functions will come in handy later!</p><p>In DuckDB, we have a <code>qualify</code> clause that we can put after <code>where</code>, which allows us to filter a row based on a window function. We can&rsquo;t use <code>where</code> to filter on the result of a window function, because <code>where</code> is necessary in order find out which rows that are part of the window. The result of the window function can&rsquo;t be known until after <code>where</code> has run! Many SQL dialects now support <code>qualify</code>, which is a super handy quality of life change. Without it, we would need to use a subquery or <a href=https://www.postgresql.org/docs/current/queries-with.html>CTE</a>.</p><p>Let&rsquo;s make a table that maps from <code>operatingDate, lineRef, directionRef</code> to the most commonly used <code>origin</code> and <code>destination</code> pair for that combination.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>%%</span><span class=k>sql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>create</span><span class=w> </span><span class=k>or</span><span class=w> </span><span class=k>replace</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>route_name</span><span class=w> </span><span class=k>as</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>with</span><span class=w> </span><span class=n>counts</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>from</span><span class=w> </span><span class=n>legs</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>select</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- This is the triple we want to name / map
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>operatingDate</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lineRef</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>directionRef</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- These are what we&#39;ll use for naming. Maybe they&#39;re stable over time?
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>min_by</span><span class=p>(</span><span class=n>from_stop</span><span class=p>,</span><span class=w> </span><span class=n>sequenceNr</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>origin</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>max_by</span><span class=p>(</span><span class=n>to_stop</span><span class=p>,</span><span class=w> </span><span class=n>sequenceNr</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>destination</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>-- We&#39;ll use this to rank them, picking the most common pair of origin/destination
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>-- as the name for the `directionRef` on this day
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=k>count</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=k>all</span><span class=w> </span><span class=c1>-- handy shortcut to group by whatever we didn&#39;t aggregate
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>from</span><span class=w> </span><span class=n>counts</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>operatingDate</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>lineRef</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>directionRef</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>origin</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>destination</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>count</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>qualify</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>max</span><span class=p>(</span><span class=k>count</span><span class=p>)</span><span class=w> </span><span class=n>over</span><span class=w> </span><span class=p>(</span><span class=n>partition</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=p>(</span><span class=n>operatingDate</span><span class=p>,</span><span class=w> </span><span class=n>lineRef</span><span class=p>,</span><span class=w> </span><span class=n>directionRef</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></div><table><thead><tr><th>Count</th></tr></thead><tbody><tr><td>149176</td></tr></tbody></table><p>Let&rsquo;s zoom in on June 2024 again, and check if this fixes our problem:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>df</span> <span class=o>=</span> <span class=n>db</span><span class=o>.</span><span class=n>sql</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>from legs join route_name using(operatingDate, directionRef, lineRef)
</span></span></span><span class=line><span class=cl><span class=s2>select count(*) as count, directionRef, 
</span></span></span><span class=line><span class=cl><span class=s2>    operatingDate, 
</span></span></span><span class=line><span class=cl><span class=s2>    origin || &#39; to &#39; || destination as route_name
</span></span></span><span class=line><span class=cl><span class=s2>where
</span></span></span><span class=line><span class=cl><span class=s2>  ((from_stop = &#39;Studentersamfundet&#39; and to_stop = &#39;Nidarosdomen&#39;) 
</span></span></span><span class=line><span class=cl><span class=s2>   or (from_stop = &#39;Nidarosdomen&#39; and to_stop = &#39;Studentersamfundet&#39;))
</span></span></span><span class=line><span class=cl><span class=s2>  and (lineRef = &#39;ATB:Line:2_3&#39; 
</span></span></span><span class=line><span class=cl><span class=s2>       and operatingDate between &#39;2024-06-01&#39; and &#39;2024-06-10&#39;)
</span></span></span><span class=line><span class=cl><span class=s2>group by all
</span></span></span><span class=line><span class=cl><span class=s2>order by operatingDate;
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>df</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sns</span><span class=o>.</span><span class=n>catplot</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>df</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=o>=</span><span class=s1>&#39;operatingDate&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=o>=</span><span class=s1>&#39;count&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>hue</span><span class=o>=</span><span class=s1>&#39;directionRef&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>col</span><span class=o>=</span><span class=s1>&#39;route_name&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>kind</span><span class=o>=</span><span class=s1>&#39;bar&#39;</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><img src=/posts/2025-05-28-turning-the-bus-sql/LinesEDA_17_0.png alt=plot><h2 id=huge-success>Huge success!<a hidden class=anchor aria-hidden=true href=#huge-success>#</a></h2><p>These stay stable even when the meaning of <code>directionRef</code> changes. Now let&rsquo;s zoom back out:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>df</span> <span class=o>=</span> <span class=n>db</span><span class=o>.</span><span class=n>sql</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>from legs join route_name using(operatingDate, directionRef, lineRef)
</span></span></span><span class=line><span class=cl><span class=s2>select count(*) as count, directionRef, 
</span></span></span><span class=line><span class=cl><span class=s2>    date_trunc(&#39;month&#39;, operatingDate) as month, 
</span></span></span><span class=line><span class=cl><span class=s2>    origin || &#39; to &#39; || destination as route_name
</span></span></span><span class=line><span class=cl><span class=s2>where
</span></span></span><span class=line><span class=cl><span class=s2>  ((from_stop = &#39;Studentersamfundet&#39; and to_stop = &#39;Nidarosdomen&#39;) 
</span></span></span><span class=line><span class=cl><span class=s2>   or (from_stop = &#39;Nidarosdomen&#39; and to_stop = &#39;Studentersamfundet&#39;))
</span></span></span><span class=line><span class=cl><span class=s2>  and lineRef = &#39;ATB:Line:2_3&#39;
</span></span></span><span class=line><span class=cl><span class=s2>group by all
</span></span></span><span class=line><span class=cl><span class=s2>order by month;
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>df</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sns</span><span class=o>.</span><span class=n>catplot</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>df</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=o>=</span><span class=s1>&#39;operatingDate&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=o>=</span><span class=s1>&#39;count&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>hue</span><span class=o>=</span><span class=s1>&#39;directionRef&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>col</span><span class=o>=</span><span class=s1>&#39;route_name&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>kind</span><span class=o>=</span><span class=s1>&#39;bar&#39;</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><img src=/posts/2025-05-28-turning-the-bus-sql/LinesEDA_19_0.png alt=plot><p>This appears to be stable all year. Great news! We&rsquo;re not entirely home-free, though.</p><p>Let me show you what I mean by sampling another lineRef:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>df</span> <span class=o>=</span> <span class=n>db</span><span class=o>.</span><span class=n>sql</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>from legs join route_name using(operatingDate, directionRef, lineRef)
</span></span></span><span class=line><span class=cl><span class=s2>select count(*) as count, directionRef, 
</span></span></span><span class=line><span class=cl><span class=s2>   date_trunc(&#39;month&#39;, operatingDate) as month, 
</span></span></span><span class=line><span class=cl><span class=s2>   origin || &#39; to &#39; || destination as route_name
</span></span></span><span class=line><span class=cl><span class=s2>where
</span></span></span><span class=line><span class=cl><span class=s2>  ((from_stop = &#39;Studentersamfundet&#39; and to_stop = &#39;Nidarosdomen&#39;) 
</span></span></span><span class=line><span class=cl><span class=s2>    or (from_stop = &#39;Nidarosdomen&#39; and to_stop = &#39;Studentersamfundet&#39;))
</span></span></span><span class=line><span class=cl><span class=s2>  and lineRef = &#39;ATB:Line:2_1&#39;)
</span></span></span><span class=line><span class=cl><span class=s2>group by all
</span></span></span><span class=line><span class=cl><span class=s2>order by month;
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>df</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sns</span><span class=o>.</span><span class=n>catplot</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>df</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=o>=</span><span class=s1>&#39;operatingDate&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=o>=</span><span class=s1>&#39;count&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>hue</span><span class=o>=</span><span class=s1>&#39;directionRef&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>col</span><span class=o>=</span><span class=s1>&#39;route_name&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>kind</span><span class=o>=</span><span class=s1>&#39;bar&#39;</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><img src=/posts/2025-05-28-turning-the-bus-sql/LinesEDA_21_0.png alt=plot><h2 id=huge-disappointment>Huge disappointment!<a hidden class=anchor aria-hidden=true href=#huge-disappointment>#</a></h2><p>Oh no, this one has more variations!</p><p>Fortunately, we can fix this too! Perhaps not perfectly, but something that should be close enough.</p><p>What should be sufficient is to set a permanent <em>directionRef</em> for each route name. We&rsquo;ll use the first directionRef we ever observed for that route. This is just a minor tweak to our <code>route_name</code> table from above:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>%%</span><span class=k>sql</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>create</span><span class=w> </span><span class=k>or</span><span class=w> </span><span class=k>replace</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>route_name</span><span class=w> </span><span class=k>as</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>with</span><span class=w> </span><span class=n>counts</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>from</span><span class=w> </span><span class=n>legs</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>select</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>operatingDate</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>lineRef</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>directionRef</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>min_by</span><span class=p>(</span><span class=n>from_stop</span><span class=p>,</span><span class=w> </span><span class=n>sequenceNr</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>origin</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>max_by</span><span class=p>(</span><span class=n>to_stop</span><span class=p>,</span><span class=w> </span><span class=n>sequenceNr</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>destination</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=k>count</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>group</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=k>all</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>from</span><span class=w> </span><span class=n>counts</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>operatingDate</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>lineRef</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>directionRef</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>-- Changed this! We&#39;ll propagate the first directionRef seen 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=c1>-- for this line/origin/destination to all of eternity
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=n>min_by</span><span class=p>(</span><span class=n>directionRef</span><span class=p>,</span><span class=w> </span><span class=n>operatingDate</span><span class=p>)</span><span class=w> </span><span class=n>over</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>partition</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=p>(</span><span class=n>lineRef</span><span class=p>,</span><span class=w> </span><span class=n>origin</span><span class=p>,</span><span class=w> </span><span class=n>destination</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>canonical_direction</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>origin</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>destination</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>count</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>qualify</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>max</span><span class=p>(</span><span class=k>count</span><span class=p>)</span><span class=w> </span><span class=n>over</span><span class=w> </span><span class=p>(</span><span class=n>partition</span><span class=w> </span><span class=k>by</span><span class=w> </span><span class=p>(</span><span class=n>operatingDate</span><span class=p>,</span><span class=w> </span><span class=n>lineRef</span><span class=p>,</span><span class=w> </span><span class=n>directionRef</span><span class=p>))</span><span class=w>
</span></span></span></code></pre></div><table><thead><tr><th>Count</th></tr></thead><tbody><tr><td>149176</td></tr></tbody></table><h2 id=did-we-conquer-line-1-now>Did we conquer line 1 now?<a hidden class=anchor aria-hidden=true href=#did-we-conquer-line-1-now>#</a></h2><p>Let&rsquo;s check whether we can use the new <code>canonical_direction</code> to separate these now:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>df</span> <span class=o>=</span> <span class=n>db</span><span class=o>.</span><span class=n>sql</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>from legs join route_name using(operatingDate, directionRef, lineRef)
</span></span></span><span class=line><span class=cl><span class=s2>select count(*) as count, 
</span></span></span><span class=line><span class=cl><span class=s2>    date_trunc(&#39;month&#39;, operatingDate) as month, 
</span></span></span><span class=line><span class=cl><span class=s2>    canonical_direction, origin || &#39; to &#39; || destination as route_name
</span></span></span><span class=line><span class=cl><span class=s2>where
</span></span></span><span class=line><span class=cl><span class=s2>  ((from_stop = &#39;Studentersamfundet&#39; and to_stop = &#39;Nidarosdomen&#39;) 
</span></span></span><span class=line><span class=cl><span class=s2>   or (from_stop = &#39;Nidarosdomen&#39; and to_stop = &#39;Studentersamfundet&#39;))
</span></span></span><span class=line><span class=cl><span class=s2>  and lineRef = &#39;ATB:Line:2_1&#39;
</span></span></span><span class=line><span class=cl><span class=s2>group by all
</span></span></span><span class=line><span class=cl><span class=s2>order by month;
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>df</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sns</span><span class=o>.</span><span class=n>catplot</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>df</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=o>=</span><span class=s1>&#39;month&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=o>=</span><span class=s1>&#39;count&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>hue</span><span class=o>=</span><span class=s1>&#39;canonical_direction&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>col</span><span class=o>=</span><span class=s1>&#39;route_name&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>kind</span><span class=o>=</span><span class=s1>&#39;bar&#39;</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><img src=/posts/2025-05-28-turning-the-bus-sql/LinesEDA_25_0.png alt=plot><h2 id=looks-pretty-good>Looks pretty good!<a hidden class=anchor aria-hidden=true href=#looks-pretty-good>#</a></h2><p>This seems to fix our main problem. This notebook wouldn&rsquo;t be complete without taking a look at what kind of difference this makes, though. Let&rsquo;s do some shallow plotting so we can compare the mean delay at the latest stop in each journey by <code>directionRef</code>, and by <code>canonical_direction</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>df</span> <span class=o>=</span> <span class=n>db</span><span class=o>.</span><span class=n>sql</span><span class=p>(</span><span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>with journey_delay as (
</span></span></span><span class=line><span class=cl><span class=s2>    from legs
</span></span></span><span class=line><span class=cl><span class=s2>    select
</span></span></span><span class=line><span class=cl><span class=s2>        operatingDate,
</span></span></span><span class=line><span class=cl><span class=s2>        serviceJourneyId,
</span></span></span><span class=line><span class=cl><span class=s2>        directionRef,
</span></span></span><span class=line><span class=cl><span class=s2>        lineRef,
</span></span></span><span class=line><span class=cl><span class=s2>        max_by(delay, sequenceNr) as delay
</span></span></span><span class=line><span class=cl><span class=s2>    where operatingDate between &#39;2024-04-15&#39; and &#39;2024-10-15&#39;
</span></span></span><span class=line><span class=cl><span class=s2>    group by all
</span></span></span><span class=line><span class=cl><span class=s2>), regular as (
</span></span></span><span class=line><span class=cl><span class=s2>    select
</span></span></span><span class=line><span class=cl><span class=s2>        operatingDate,
</span></span></span><span class=line><span class=cl><span class=s2>        quantile_disc(delay, .75) as delay,
</span></span></span><span class=line><span class=cl><span class=s2>        directionRef,
</span></span></span><span class=line><span class=cl><span class=s2>        &#39;directionRef&#39; as kind
</span></span></span><span class=line><span class=cl><span class=s2>    from journey_delay
</span></span></span><span class=line><span class=cl><span class=s2>    where lineRef = &#39;ATB:Line:2_3&#39;
</span></span></span><span class=line><span class=cl><span class=s2>    group by all
</span></span></span><span class=line><span class=cl><span class=s2>    order by operatingDate, directionRef
</span></span></span><span class=line><span class=cl><span class=s2>), canonical as (
</span></span></span><span class=line><span class=cl><span class=s2>    select
</span></span></span><span class=line><span class=cl><span class=s2>        operatingDate,
</span></span></span><span class=line><span class=cl><span class=s2>        quantile_disc(delay, .75) as delay,
</span></span></span><span class=line><span class=cl><span class=s2>        route_name.canonical_direction as directionRef,
</span></span></span><span class=line><span class=cl><span class=s2>        &#39;canonical&#39; as kind
</span></span></span><span class=line><span class=cl><span class=s2>    from journey_delay join route_name using(operatingDate, lineRef, directionRef)
</span></span></span><span class=line><span class=cl><span class=s2>    where lineRef = &#39;ATB:Line:2_3&#39;
</span></span></span><span class=line><span class=cl><span class=s2>    group by all
</span></span></span><span class=line><span class=cl><span class=s2>    order by operatingDate, directionRef
</span></span></span><span class=line><span class=cl><span class=s2>)
</span></span></span><span class=line><span class=cl><span class=s2>select * from regular
</span></span></span><span class=line><span class=cl><span class=s2>union all
</span></span></span><span class=line><span class=cl><span class=s2>select * from canonical
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>df</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sns</span><span class=o>.</span><span class=n>relplot</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>df</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=o>=</span><span class=s1>&#39;operatingDate&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=o>=</span><span class=s1>&#39;delay&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>hue</span><span class=o>=</span><span class=s1>&#39;kind&#39;</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>    <span class=n>col</span><span class=o>=</span><span class=s1>&#39;directionRef&#39;</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>kind</span><span class=o>=</span><span class=s1>&#39;line&#39;</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><img src=/posts/2025-05-28-turning-the-bus-sql/LinesEDA_27_0.png alt=plot><p>Makes a difference! I&rsquo;ll make a job that keeps something like the <code>route_name</code> table up to date so that I can keep track of the &ldquo;true&rdquo; direction of a line for my analysis. Should be fun to see if this works with all ~500 million legs in the main data set! I&rsquo;m sure it&rsquo;ll be fine; DuckDB chews through this notebook in just a few seconds after the initial download is done.</p><p>Thanks for reading!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kaveland.no/tags/data/>Data</a></li><li><a href=https://kaveland.no/tags/sql/>Sql</a></li><li><a href=https://kaveland.no/tags/duckdb/>Duckdb</a></li><li><a href=https://kaveland.no/tags/seaborn/>Seaborn</a></li><li><a href=https://kaveland.no/tags/visualization/>Visualization</a></li></ul><nav class=paginav><a class=prev href=https://kaveland.no/posts/2025-06-06-library/><span class=title>« Prev</span><br><span>The librarian immediately attempts to sell you a vuvuzela</span>
</a><a class=next href=https://kaveland.no/posts/2025-05-14-fire-and-forget-linux-p3/><span class=title>Next »</span><br><span>No-ops linux part 3: It puts the data in the pond. Nightly.</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Using SQL to turn all the buses around on x" href="https://x.com/intent/tweet/?text=Using%20SQL%20to%20turn%20all%20the%20buses%20around&amp;url=https%3a%2f%2fkaveland.no%2fposts%2f2025-05-28-turning-the-bus-sql%2f&amp;hashtags=data%2csql%2cduckdb%2cseaborn%2cvisualization"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using SQL to turn all the buses around on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkaveland.no%2fposts%2f2025-05-28-turning-the-bus-sql%2f&amp;title=Using%20SQL%20to%20turn%20all%20the%20buses%20around&amp;summary=Using%20SQL%20to%20turn%20all%20the%20buses%20around&amp;source=https%3a%2f%2fkaveland.no%2fposts%2f2025-05-28-turning-the-bus-sql%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using SQL to turn all the buses around on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkaveland.no%2fposts%2f2025-05-28-turning-the-bus-sql%2f&title=Using%20SQL%20to%20turn%20all%20the%20buses%20around"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using SQL to turn all the buses around on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkaveland.no%2fposts%2f2025-05-28-turning-the-bus-sql%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using SQL to turn all the buses around on whatsapp" href="https://api.whatsapp.com/send?text=Using%20SQL%20to%20turn%20all%20the%20buses%20around%20-%20https%3a%2f%2fkaveland.no%2fposts%2f2025-05-28-turning-the-bus-sql%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using SQL to turn all the buses around on telegram" href="https://telegram.me/share/url?text=Using%20SQL%20to%20turn%20all%20the%20buses%20around&amp;url=https%3a%2f%2fkaveland.no%2fposts%2f2025-05-28-turning-the-bus-sql%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using SQL to turn all the buses around on ycombinator" href="https://news.ycombinator.com/submitlink?t=Using%20SQL%20to%20turn%20all%20the%20buses%20around&u=https%3a%2f%2fkaveland.no%2fposts%2f2025-05-28-turning-the-bus-sql%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kaveland.no/>Robin's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>