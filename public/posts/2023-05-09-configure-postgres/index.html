<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Protecting your postgres server from your application | Robin's blog</title>
<meta name=keywords content="postgres"><meta name=description content="There are 2 configuration options that every OLTP application that uses postgres
should set, in order to protect the database from high load:

statement_timeout
idle_in_transaction_session_timeout

These can both be set by client configuration and require no special
permissions to set, and are easily overridden locally for transactions that have
different requirements.
They can be a bit scary to retrofit to existing applications, but we can
activate two postgres extensions to help us measure our queries to find safe
values to set:"><meta name=author content="Robin Kåveland"><link rel=canonical href=https://kaveland.no/posts/2023-05-09-configure-postgres/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://kaveland.no/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kaveland.no/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kaveland.no/favicon-32x32.png><link rel=apple-touch-icon href=https://kaveland.no/apple-touch-icon.png><link rel=mask-icon href=https://kaveland.no/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kaveland.no/posts/2023-05-09-configure-postgres/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer data-domain=kaveland.no src=https://plausible.io/js/script.js></script><meta property="og:title" content="Protecting your postgres server from your application"><meta property="og:description" content="There are 2 configuration options that every OLTP application that uses postgres
should set, in order to protect the database from high load:

statement_timeout
idle_in_transaction_session_timeout

These can both be set by client configuration and require no special
permissions to set, and are easily overridden locally for transactions that have
different requirements.
They can be a bit scary to retrofit to existing applications, but we can
activate two postgres extensions to help us measure our queries to find safe
values to set:"><meta property="og:type" content="article"><meta property="og:url" content="https://kaveland.no/posts/2023-05-09-configure-postgres/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-09T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-09T00:00:00+00:00"><meta property="og:site_name" content="Robin's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Protecting your postgres server from your application"><meta name=twitter:description content="There are 2 configuration options that every OLTP application that uses postgres
should set, in order to protect the database from high load:

statement_timeout
idle_in_transaction_session_timeout

These can both be set by client configuration and require no special
permissions to set, and are easily overridden locally for transactions that have
different requirements.
They can be a bit scary to retrofit to existing applications, but we can
activate two postgres extensions to help us measure our queries to find safe
values to set:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kaveland.no/posts/"},{"@type":"ListItem","position":2,"name":"Protecting your postgres server from your application","item":"https://kaveland.no/posts/2023-05-09-configure-postgres/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Protecting your postgres server from your application","name":"Protecting your postgres server from your application","description":"There are 2 configuration options that every OLTP application that uses postgres should set, in order to protect the database from high load:\nstatement_timeout idle_in_transaction_session_timeout These can both be set by client configuration and require no special permissions to set, and are easily overridden locally for transactions that have different requirements.\nThey can be a bit scary to retrofit to existing applications, but we can activate two postgres extensions to help us measure our queries to find safe values to set:\n","keywords":["postgres"],"articleBody":"There are 2 configuration options that every OLTP application that uses postgres should set, in order to protect the database from high load:\nstatement_timeout idle_in_transaction_session_timeout These can both be set by client configuration and require no special permissions to set, and are easily overridden locally for transactions that have different requirements.\nThey can be a bit scary to retrofit to existing applications, but we can activate two postgres extensions to help us measure our queries to find safe values to set:\npg_stat_statements auto_explain It’s also a really good idea to monitor how many connections that are actively used on the database server. You may have integration with a good monitoring tool on the application side already, but if you don’t, you can easily set up very useful monitoring by sampling the pg_stat_activity view.\nstatement_timeout The official documentation has this to say:\nAbort any statement that takes more than the specified amount of time. If log_min_error_statement is set to ERROR or lower, the statement that timed out will also be logged. If this value is specified without units, it is taken as milliseconds. A value of zero (the default) disables the timeout.\nUsually you want to set it in the application configuration, for example in the connection pool configuration. If you use HikariCP it makes sense to configure your pool with:\npool.setConnectionInitSql(\"set statement_timeout = 1000\"); Any transaction can set statement_timeout at any time, so if some queries must be allowed to run longer, it’s easy to apply this setting locally (but remember to set it back to the default once you’re done with the connection). It’s not a good idea to set a database level default or server default, since it may interfere with migrations or analytical queries.\nThe effect of this is that any statement that causes a connection to postgres to be in an active state longer than statement_timeout is canceled. This is important to set because if you don’t have it, the database will keep chugging along even if the application gives up on the query, consuming hardware resources that might be required to complete other queries, causing everything to slow down. This kind of problem can be very difficult to debug, because code paths that aren’t really problematic might start failing. It is much easier to figure out what’s wrong if the problematic code path fails quickly.\nSuppose the following happens:\nSome result that needs to be sorted grows too large to be sorted in memory, causing the database to sort using temporary files, slowing a query down from a few milliseconds to many seconds. A user requests a page that runs this query, and the page appears to hang. The user waits a couple of seconds, then tries to refresh the page. This may happen more than once. At this point the database has N copies of the problematic query running, each using lots of IO capacity. All N copies of the query and all other queries that hit disk now contend to get IO time, slowing everything down to a crawl. The database does not know that the application isn’t interested in the result of the first N - 1 copies of the query that the user canceled. This is what statement_timeout protects you against. Even if you set it to a high value like 2 seconds or 5 seconds, it’s still valuable, to prevent 1 user from being able to use up all database server resources by accident, which they can easily do if they encounter a page that runs a pathologically bad query.\nstatement_timeout will also cancel transactions that wait a long time to obtain locks, helping you prevent your connection pool from running out of connections if you have some accidental locking or queueing for locks.\nSetting idle_in_transaction_session_timeout This setting terminates connections that have started a transaction that did not either roll back or commit before the timeout occurs. A typical case of this might be that the application does some HTTP requests while holding an open transaction. If the application has taken locks in the database and forgot to set appropriate HTTP timeouts, this could cause pretty big problems for other traffic, so it’s normally something you’d want to avoid just to be on the safe side. This setting can also be configured using set:\npool.setConnectionInitSql(\"set statement_timeout = 1000; set idle_in_transaction_session_timeout = 1000\"); Adding timeouts to an existing application By default both statement_timeout and idle_in_transaction_session_timeout are set to 0, which disables them. If you didn’t read up on this before setting up the application, it might seem very scary to set these up after the fact. Don’t worry though, there are helpful tools in postgres that you can use to identify good timeout values for your application, although you may need some help from a DBA to enable them.\nThere are two very useful postgres extensions that should be fairly uncontroversial to enable:\npg_stat_statements This extension can track a number of metrics about the queries that your application actually runs in your database, these are the most useful ones to know about:\nHow many times the query is run How much time does it take on average, the highest recorded runtime, the standard deviation How often does it cause a cache miss or spill something to temp files on disk If you enable pg_stat_statements.track_planning, it will also tell you how much time it takes to plan the query. You enable this extension in postgresql.conf, for example:\nshared_preload_libraries = 'pg_stat_statements' pg_stat_statements.track_planning = on After it has been activated on the server, it needs to be created in the databases that you plan to monitor:\ncreate extension pg_stat_statements There are many ways you can try to use this view to find out if you have queries that would be impacted by statement_timeout. You can reset the stats by running:\nselect pg_stat_statements_reset(); Note that some queries will take a lot longer to execute immedately after a database restart, because many of the index and table files might not be in server RAM yet.\nauto_explain This extension serves 2 very useful purposes:\nIt will help you identify slow queries It will go some way towards telling you why the query is slow by logging the query plan There are a number of options you can configure here:\nauto_explain.log_min_duration the threshold, in milliseconds, that causes a query to be explained in the log auto_explain.log_analyze enables the analyze option of explain for the output that ends up in the log. In short this will give you the actual row counts of the different query plan nodes, and optionally also buffers and timing. This can be costly on some hardware. auto_explain.log_timing enables actual time taken for query plan nodes, which is often very useful, but can also be very expensive. It does nothing withoutauto_explain.log_analyze. You can disable this to make auto_explain.log_analyze cheaper. auto_explain.log_buffers will log enable the buffers option for explain, helping you identify whether the queries hit disk or read from the buffer cache. This does nothing without auto_explain.log_analyze. Configuring both pg_stat_statements and auto_explain might look like this:\nshared_preload_libraries = 'pg_stat_statements,auto_explain' pg_stat_statements.track_planning = on auto_explain.log_min_duration = '100ms' auto_explain.log_analyze = on auto_explain.log_buffers = on auto_explain.log_timing = off Sampling pg_stat_activity for monitoring The pg_stat_activity view is an excellent target for monitoring your connection pools, but since it represents a snapshot in time, naively sampling it will make it easy to miss peak connection usage, which is what’s actually interesting. To some extent it’s possible to improve this by taking samples more often but it’s probably a better idea to make use of the state_change column to find out how many connections that have been idle for the last sampling duration.\nSuppose you sample every 10 seconds, then the following query will give you the count of connections that have been completely idle since the last sampling, which will help you estimate your free capacity:\nselect count(*) from pg_stat_activity where state = 'idle' and now() - state_change \u003c= interval '10 seconds' You can easily add group by datname, usename if you have multiple users/databases on the same database server.\nNote that there are a lot of different kinds of problems that may cause increase usage of connections to the database, but the most common one will be queries that are run with inefficient query plans, where auto_explain is a really good tool to help you figure out how to fix it.\n","wordCount":"1391","inLanguage":"en","datePublished":"2023-05-09T00:00:00Z","dateModified":"2023-05-09T00:00:00Z","author":{"@type":"Person","name":"Robin Kåveland"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kaveland.no/posts/2023-05-09-configure-postgres/"},"publisher":{"@type":"Organization","name":"Robin's blog","logo":{"@type":"ImageObject","url":"https://kaveland.no/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kaveland.no/ accesskey=h title="Robin's blog (Alt + H)">Robin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kaveland.no/about/ title=about><span>about</span></a></li><li><a href=https://kaveland.no/projects/ title=projects><span>projects</span></a></li><li><a href=https://kaveland.no/eugene/ title=eugene><span>eugene</span></a></li><li><a href=https://kaveland.no/thumper/ title=thumper><span>thumper</span></a></li><li><a href=https://kaveland.no/tags/ title=tags><span>tags</span></a></li><li><a href=https://kaveland.no/archives/ title=archives><span>archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kaveland.no/>Home</a>&nbsp;»&nbsp;<a href=https://kaveland.no/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Protecting your postgres server from your application</h1><div class=post-meta><span title='2023-05-09 00:00:00 +0000 UTC'>May 9, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1391 words&nbsp;·&nbsp;Robin Kåveland&nbsp;|&nbsp;<a href=https://github.com/kaaveland/kaaveland.github.io/content/posts/2023-05-09-configure-postgres.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#statement_timeout><code>statement_timeout</code></a></li><li><a href=#setting-idle_in_transaction_session_timeout>Setting <code>idle_in_transaction_session_timeout</code></a></li></ul><ul><li><a href=#pg_stat_statements><a href=https://www.postgresql.org/docs/current/pgstatstatements.html><code>pg_stat_statements</code></a></a></li><li><a href=#auto_explain><a href=https://www.postgresql.org/docs/current/auto-explain.html><code>auto_explain</code></a></a></li><li><a href=#sampling-pg_stat_activity-for-monitoring>Sampling <code>pg_stat_activity</code> for monitoring</a></li></ul></nav></div></details></div><div class=post-content><p>There are 2 configuration options that every OLTP application that uses postgres
should set, in order to protect the database from high load:</p><ul><li><code>statement_timeout</code></li><li><code>idle_in_transaction_session_timeout</code></li></ul><p>These can both be set by client configuration and require no special
permissions to set, and are easily overridden locally for transactions that have
different requirements.</p><p>They can be a bit scary to retrofit to existing applications, but we can
activate two postgres extensions to help us measure our queries to find safe
values to set:</p><ul><li><code>pg_stat_statements</code></li><li><code>auto_explain</code></li></ul><p>It&rsquo;s also a really good idea to monitor how many connections that are actively
used on the database server. You may have integration with a good monitoring
tool on the application side already, but if you don&rsquo;t, you can easily set
up very useful monitoring by sampling the <code>pg_stat_activity</code> view.</p><h2 id=statement_timeout><code>statement_timeout</code><a hidden class=anchor aria-hidden=true href=#statement_timeout>#</a></h2><p>The <a href=https://www.postgresql.org/docs/current/runtime-config-client.html>official documentation</a>
has this to say:</p><blockquote><p>Abort any statement that takes more than the specified amount of time. If
log_min_error_statement is set to ERROR or lower, the statement that timed out
will also be logged. If this value is specified without units, it is taken as
milliseconds. A value of zero (the default) disables the timeout.</p></blockquote><p>Usually you want to set it in the application configuration, for example in the
connection pool configuration. If you use
<a href=https://github.com/brettwooldridge/HikariCP#infrequently-used>HikariCP</a> it
makes sense to configure your pool with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>pool</span><span class=p>.</span><span class=na>setConnectionInitSql</span><span class=p>(</span><span class=s>&#34;set statement_timeout = 1000&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>Any transaction can <code>set statement_timeout</code> at any time, so if some queries must
be allowed to run longer, it&rsquo;s easy to apply this setting locally (but remember
to set it back to the default once you&rsquo;re done with the connection). It&rsquo;s not a
good idea to set a database level default or server default, since it may
interfere with migrations or analytical queries.</p><p>The effect of this is that any statement that causes a connection to postgres to
be in an active state longer than <code>statement_timeout</code> is canceled. This is
important to set because if you don&rsquo;t have it, the database will keep chugging
along even if the application gives up on the query, consuming hardware
resources that might be required to complete other queries, causing everything
to slow down. This kind of problem can be very difficult to debug, because
code paths that aren&rsquo;t really problematic might start failing. It is much easier
to figure out what&rsquo;s wrong if the problematic code path fails quickly.</p><p>Suppose the following happens:</p><ol><li>Some result that needs to be sorted grows too large to be sorted in memory,
causing the database to sort using temporary files, slowing a query down
from a few milliseconds to many seconds.</li><li>A user requests a page that runs this query, and the page appears to hang.
The user waits a couple of seconds, then tries to refresh the page. This may
happen more than once.</li><li>At this point the database has N copies of the problematic query running,
each using lots of IO capacity. All N copies of the query and all other
queries that hit disk now contend to get IO time, slowing everything down to
a crawl. The database does not know that the application isn&rsquo;t interested in
the result of the first N - 1 copies of the query that the user canceled.</li></ol><p>This is what <code>statement_timeout</code> protects you against. Even if you set it to a
high value like 2 seconds or 5 seconds, it&rsquo;s still valuable, to prevent 1 user
from being able to use up all database server resources by accident, which they
can easily do if they encounter a page that runs a pathologically bad query.</p><p><code>statement_timeout</code> will also cancel transactions that wait a long time to
obtain locks, helping you prevent your connection pool from running out of
connections if you have some accidental locking or queueing for locks.</p><h2 id=setting-idle_in_transaction_session_timeout>Setting <code>idle_in_transaction_session_timeout</code><a hidden class=anchor aria-hidden=true href=#setting-idle_in_transaction_session_timeout>#</a></h2><p>This setting terminates connections that have started a transaction that
did not either roll back or commit before the timeout occurs. A typical
case of this might be that the application does some HTTP requests while
holding an open transaction. If the application has taken locks in the database
and forgot to set appropriate HTTP timeouts, this could cause pretty big
problems for other traffic, so it&rsquo;s normally something you&rsquo;d want to avoid just
to be on the safe side. This setting can also be configured using <code>set</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>pool</span><span class=p>.</span><span class=na>setConnectionInitSql</span><span class=p>(</span><span class=s>&#34;set statement_timeout = 1000; set idle_in_transaction_session_timeout = 1000&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><h1 id=adding-timeouts-to-an-existing-application>Adding timeouts to an existing application<a hidden class=anchor aria-hidden=true href=#adding-timeouts-to-an-existing-application>#</a></h1><p>By default both <code>statement_timeout</code> and <code>idle_in_transaction_session_timeout</code>
are set to <code>0</code>, which disables them. If you didn&rsquo;t read up on this before
setting up the application, it might seem very scary to set these up after the
fact. Don&rsquo;t worry though, there are helpful tools in postgres that you can use
to identify good timeout values for your application, although you may need
some help from a DBA to enable them.</p><p>There are two very useful postgres extensions that should be fairly
uncontroversial to enable:</p><h2 id=pg_stat_statements><a href=https://www.postgresql.org/docs/current/pgstatstatements.html><code>pg_stat_statements</code></a><a hidden class=anchor aria-hidden=true href=#pg_stat_statements>#</a></h2><p>This extension can track a number of metrics about the queries that your
application actually runs in your database, these are the most useful ones to
know about:</p><ul><li>How many times the query is run</li><li>How much time does it take on average, the highest recorded runtime, the
standard deviation</li><li>How often does it cause a cache miss or spill something to temp files on disk</li></ul><p>If you enable <code>pg_stat_statements.track_planning</code>, it will also tell you how
much time it takes to plan the query. You enable this extension in
<code>postgresql.conf</code>, for example:</p><pre tabindex=0><code>shared_preload_libraries = &#39;pg_stat_statements&#39;
pg_stat_statements.track_planning = on
</code></pre><p>After it has been activated on the server, it needs to be <code>create</code>d in the
databases that you plan to monitor:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>create</span><span class=w> </span><span class=n>extension</span><span class=w> </span><span class=n>pg_stat_statements</span><span class=w>
</span></span></span></code></pre></div><p>There are many ways you can try to use this view to find out if you have queries
that would be impacted by <code>statement_timeout</code>. You can reset the stats by
running:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=n>pg_stat_statements_reset</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>Note that some queries will take a lot longer to execute immedately after a
database restart, because many of the index and table files might not be in
server RAM yet.</p><h2 id=auto_explain><a href=https://www.postgresql.org/docs/current/auto-explain.html><code>auto_explain</code></a><a hidden class=anchor aria-hidden=true href=#auto_explain>#</a></h2><p>This extension serves 2 very useful purposes:</p><ul><li>It will help you identify slow queries</li><li>It will go some way towards telling you why the query is slow by logging the
query plan</li></ul><p>There are a number of options you can configure here:</p><ul><li><code>auto_explain.log_min_duration</code> the threshold, in milliseconds, that causes a
query to be <code>explained</code> in the log</li><li><code>auto_explain.log_analyze</code> enables the <code>analyze</code> option of <code>explain</code> for the
output that ends up in the log. In short this will give you the actual row
counts of the different query plan nodes, and optionally also buffers and
timing. This can be costly on some hardware.</li><li><code>auto_explain.log_timing</code> enables actual time taken for query plan nodes,
which is often very useful, but can also be very expensive. It does nothing
without<code>auto_explain.log_analyze</code>. You can disable this to make
<code>auto_explain.log_analyze</code> cheaper.</li><li><code>auto_explain.log_buffers</code> will log enable the <code>buffers</code> option for explain,
helping you identify whether the queries hit disk or read from the buffer
cache. This does nothing without <code>auto_explain.log_analyze</code>.</li></ul><p>Configuring both <code>pg_stat_statements</code> and <code>auto_explain</code> might look like this:</p><pre tabindex=0><code>shared_preload_libraries = &#39;pg_stat_statements,auto_explain&#39;
pg_stat_statements.track_planning = on
auto_explain.log_min_duration = &#39;100ms&#39;
auto_explain.log_analyze = on
auto_explain.log_buffers = on
auto_explain.log_timing = off
</code></pre><h2 id=sampling-pg_stat_activity-for-monitoring>Sampling <code>pg_stat_activity</code> for monitoring<a hidden class=anchor aria-hidden=true href=#sampling-pg_stat_activity-for-monitoring>#</a></h2><p>The <a href=https://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEWhttps://www.postgresql.org/docs/current/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-VIEW><code>pg_stat_activity</code></a>
view is an excellent target for monitoring your connection pools, but since it
represents a snapshot in time, naively sampling it will make it easy to miss
peak connection usage, which is what&rsquo;s actually interesting. To some extent
it&rsquo;s possible to improve this by taking samples more often but it&rsquo;s probably
a better idea to make use of the <code>state_change</code> column to find
out how many connections that have been idle for the last sampling duration.</p><p>Suppose you sample every 10 seconds, then the following query will give you
the count of connections that have been completely idle since the last sampling,
which will help you estimate your free capacity:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>from</span><span class=w> </span><span class=n>pg_stat_activity</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>where</span><span class=w> </span><span class=k>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;idle&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>now</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>state_change</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=nb>interval</span><span class=w> </span><span class=s1>&#39;10 seconds&#39;</span><span class=w>
</span></span></span></code></pre></div><p>You can easily add <code>group by datname, usename</code> if you have multiple
users/databases on the same database server.</p><p>Note that there are a lot of different kinds of problems that may cause increase
usage of connections to the database, but the most common one will be queries
that are run with inefficient query plans, where <code>auto_explain</code> is a really good
tool to help you figure out how to fix it.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kaveland.no/tags/postgres/>Postgres</a></li></ul><nav class=paginav><a class=prev href=https://kaveland.no/posts/2024-03-10-testing-transactions-that-commit/><span class=title>« Prev</span><br><span>Isolating integration tests that commit transactions</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Protecting your postgres server from your application on x" href="https://x.com/intent/tweet/?text=Protecting%20your%20postgres%20server%20from%20your%20application&amp;url=https%3a%2f%2fkaveland.no%2fposts%2f2023-05-09-configure-postgres%2f&amp;hashtags=postgres"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Protecting your postgres server from your application on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkaveland.no%2fposts%2f2023-05-09-configure-postgres%2f&amp;title=Protecting%20your%20postgres%20server%20from%20your%20application&amp;summary=Protecting%20your%20postgres%20server%20from%20your%20application&amp;source=https%3a%2f%2fkaveland.no%2fposts%2f2023-05-09-configure-postgres%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Protecting your postgres server from your application on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkaveland.no%2fposts%2f2023-05-09-configure-postgres%2f&title=Protecting%20your%20postgres%20server%20from%20your%20application"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Protecting your postgres server from your application on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkaveland.no%2fposts%2f2023-05-09-configure-postgres%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Protecting your postgres server from your application on whatsapp" href="https://api.whatsapp.com/send?text=Protecting%20your%20postgres%20server%20from%20your%20application%20-%20https%3a%2f%2fkaveland.no%2fposts%2f2023-05-09-configure-postgres%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Protecting your postgres server from your application on telegram" href="https://telegram.me/share/url?text=Protecting%20your%20postgres%20server%20from%20your%20application&amp;url=https%3a%2f%2fkaveland.no%2fposts%2f2023-05-09-configure-postgres%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Protecting your postgres server from your application on ycombinator" href="https://news.ycombinator.com/submitlink?t=Protecting%20your%20postgres%20server%20from%20your%20application&u=https%3a%2f%2fkaveland.no%2fposts%2f2023-05-09-configure-postgres%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kaveland.no/>Robin's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>