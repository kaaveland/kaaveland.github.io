<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linting postgres migration scripts | Robin's blog</title>
<meta name=keywords content="postgres,rust,eugene"><meta name=description content="I have been working quite a bit on picking up dangerous migration patterns in
migration scripts over at the eugene repository
lately. A major feature I&rsquo;ve added is syntax tree analysis, so that we can pick
up some patterns without having to run the SQL scripts. This isn&rsquo;t quite as precise
as running the scripts, but it&rsquo;s a lot faster and can catch quite a few
common mistakes. So let&rsquo;s take a look at how it works!"><meta name=author content="Robin Kåveland"><link rel=canonical href=https://kaveland.no/posts/2024-05-16-linting-postgres-migration-scripts/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://kaveland.no/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kaveland.no/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kaveland.no/favicon-32x32.png><link rel=apple-touch-icon href=https://kaveland.no/apple-touch-icon.png><link rel=mask-icon href=https://kaveland.no/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kaveland.no/posts/2024-05-16-linting-postgres-migration-scripts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer data-domain=kaveland.no src=https://plausible.io/js/script.js></script><meta property="og:title" content="Linting postgres migration scripts"><meta property="og:description" content="I have been working quite a bit on picking up dangerous migration patterns in
migration scripts over at the eugene repository
lately. A major feature I&rsquo;ve added is syntax tree analysis, so that we can pick
up some patterns without having to run the SQL scripts. This isn&rsquo;t quite as precise
as running the scripts, but it&rsquo;s a lot faster and can catch quite a few
common mistakes. So let&rsquo;s take a look at how it works!"><meta property="og:type" content="article"><meta property="og:url" content="https://kaveland.no/posts/2024-05-16-linting-postgres-migration-scripts/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-16T00:00:00+00:00"><meta property="article:modified_time" content="2024-05-18T00:00:00+00:00"><meta property="og:site_name" content="Robin's blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linting postgres migration scripts"><meta name=twitter:description content="I have been working quite a bit on picking up dangerous migration patterns in
migration scripts over at the eugene repository
lately. A major feature I&rsquo;ve added is syntax tree analysis, so that we can pick
up some patterns without having to run the SQL scripts. This isn&rsquo;t quite as precise
as running the scripts, but it&rsquo;s a lot faster and can catch quite a few
common mistakes. So let&rsquo;s take a look at how it works!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kaveland.no/posts/"},{"@type":"ListItem","position":2,"name":"Linting postgres migration scripts","item":"https://kaveland.no/posts/2024-05-16-linting-postgres-migration-scripts/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linting postgres migration scripts","name":"Linting postgres migration scripts","description":"I have been working quite a bit on picking up dangerous migration patterns in migration scripts over at the eugene repository lately. A major feature I\u0026rsquo;ve added is syntax tree analysis, so that we can pick up some patterns without having to run the SQL scripts. This isn\u0026rsquo;t quite as precise as running the scripts, but it\u0026rsquo;s a lot faster and can catch quite a few common mistakes. So let\u0026rsquo;s take a look at how it works!\n","keywords":["postgres","rust","eugene"],"articleBody":"I have been working quite a bit on picking up dangerous migration patterns in migration scripts over at the eugene repository lately. A major feature I’ve added is syntax tree analysis, so that we can pick up some patterns without having to run the SQL scripts. This isn’t quite as precise as running the scripts, but it’s a lot faster and can catch quite a few common mistakes. So let’s take a look at how it works!\nLinting SQL with pq_query.rs One of the fun things about writing eugene in Rust, is that I get to use native libraries. This is a pretty useful capability to have, as it turns out that SQL is a really huge language that is painful to parse, and there is an excellent open source parser for it in Postgres itself.\npg_query.rs is a Rust wrapper around the Postgres parser, and it’s been really easy to start using it, by just running cargo add pg_query.\nNote that this doesn’t mean it’s easy to use! Or rather, it’s not that hard to use, but even though someone else wrote the parser, the language itself is still huge and complex. But it’s done now, eugene lint can parse SQL and give some useful hints:\neugene lint -f json examples/alter_column_unique.sql { \"name\": \"examples/alter_column_unique.sql\", \"lints\": [ { \"statement_number\": 1, \"sql\": \"alter table books add constraint unique_title unique(title)\", \"lints\": [ { \"id\": \"E7\", \"name\": \"Creating a new unique constraint\", \"condition\": \"Found a new unique constraint and a new index\", \"effect\": \"This blocks all writes to the table while the index is being created and validated\", \"workaround\": \"`CREATE UNIQUE INDEX CONCURRENTLY`, then add the constraint using the index\", \"help\": \"New constraint unique_title creates implicit index on `public.books`, blocking writes until index is created and validated\" }, { \"id\": \"E9\", \"name\": \"Taking dangerous lock without timeout\", \"condition\": \"A lock that would block many common operations was taken without a timeout\", \"effect\": \"This can block all other operations on the table indefinitely if any other transaction holds a conflicting lock while `idle in transaction` or `active`\", \"workaround\": \"Run `SET LOCAL lock_timeout = '2s';` before the statement and retry the migration if necessary\", \"help\": \"Statement takes lock on `public.books`, but does not set a lock timeout\" } ] } ] } Splitting a SQL script into statements is super simple:\n/// Separate SQL script into statements pub fn sql_statements(sql: \u0026str) -\u003e Result\u003cVec\u003c\u0026str\u003e\u003e { Ok(pg_query::split_with_parser(sql)? .into_iter() .map(|s| s.trim()) .collect()) } Parsing a statement is also pretty simple, you just call pg_query::parse. The hard part starts once you have gotten the syntax tree.\nNavigating pg_query::NodeRef At the start, I tried to work with the enum pg_query::NodeRef. This uses a nice pattern I hadn’t seen before, here’s an excerpt:\n#[derive(Debug, Copy, Clone)] pub enum NodeRef\u003c'a\u003e { Alias(\u0026'a protobuf::Alias), RangeVar(\u0026'a protobuf::RangeVar), TableFunc(\u0026'a protobuf::TableFunc), // ... } Each of the variants of NodeRef contains a reference to a protobuf struct (generated by prost) that contains the actual data.\nThis is much nicer to work with than putting the actual data in enum variants, because it means you can type a function to accept “the variant”, so it’s clear what kind of data it expects, and you avoid having to match on the enum in more than one place. This kind of makes it feel like a scala sealed trait with case classes in terms of capabilities, which is nice. The disadvantage is that there’s an extra layer of unpacking to do in matches, in order to get the data, you’d have to do something like this to bind the aliasname field of an Alias:\nfn example(stmt: pg_query::NodeRef) { match stmt { NodeRef::Alias(pg_query::protobuf::Alias { aliasname, .. }) =\u003e {} // Do something with `aliasname` _ =\u003e {} } } NodeRef and its sibling Node turn up in a lot of places in the protobuf structs, and are a bit difficult to work with, with all the borrowing, referencing and this extra layer.\nFor this reason I decided to translate the part of the grammar I wanted to analyze into something that was easier to work with, which I named StatementSummary:\n#[derive(Debug, Clone, PartialEq, Eq)] pub enum StatementSummary { Ignored, LockTimeout, CreateTable { // ... }, CreateTableAs { // ... }, CreateIndex { // ... }, AlterTable { // ... }, } pub fn describe(statement: \u0026pg_query::NodeRef) -\u003e anyhow::Result\u003cStatementSummary\u003e { match statement { pg_query::NodeRef::VariableSetStmt(child) =\u003e set_statement(child), pg_query::NodeRef::CreateStmt(child) =\u003e create_table(child), pg_query::NodeRef::CreateTableAsStmt(child) =\u003e create_table_as(child), pg_query::NodeRef::IndexStmt(child) =\u003e create_index(child), pg_query::NodeRef::AlterTableStmt(child) =\u003e alter_table(child), _ =\u003e Ok(StatementSummary::Ignored), } } Note that because of the way the protobuf structs are typed, we’re being forced to return Result instead of StatementSummary because something like NodeRef::CreateStmt contains Vec in its .table_elt attribute, instead of a more narrow type, so there is no guarantee in the types that a table element isn’t something like a CreateMaterializedViewStmt, even though we know that the parser would never do that to us.\nOnce the translation is done, we have something that’s pretty easy to lint against, but it is still context free. We can’t know if a CREATE INDEX statement is dangerous without knowing whether the table it’s created on is visible to other transactions or not. For that reason, we also need to keep track of some sort of context, or result, of the transaction so far.\nI named this concept a TransactionState and it looks like this:\n#[derive(Debug, Default, Eq, PartialEq)] pub struct TransactionState { locktimeout: bool, created_objects: Vec\u003c(String, String)\u003e, altered_tables: Vec\u003c(String, String)\u003e, has_access_exclusive: bool, } #[derive(Copy, Clone)] pub struct LintContext\u003c'a\u003e { pub(crate) ctx: \u0026'a TransactionState, pub(crate) statement: \u0026'a StatementSummary, } When bundled together with the StatementSummary, we can start to write some useful rules.\nWriting rules Initially, I wanted to aim for feature parity with the eugene trace command. This is pretty difficult, because the eugene trace command actually runs the SQL scripts, and can inspect their effects, whereas we’re going to be working with a static analysis only. But once I started writing rules, I realized that we may be able to implement most rules that eugene trace has, it’s just going to be less precise.\nFor example, here’s the check for create index without concurrently:\nfn create_index_nonconcurrently(stmt: LintContext) -\u003e Option\u003cString\u003e { match stmt.statement { StatementSummary::CreateIndex { schema, idxname, target, concurrently: false, .. } if stmt.is_visible(schema, target) =\u003e { let schema = if schema.is_empty() { \"public\" } else { schema }; Some(format!(\"Statement takes `ShareLock` on `{schema}.{target}`, blocking \\ writes while creating index `{schema}.{idxname}`\")) } _ =\u003e None, } } eugene trace gets to just check if the transaction holds ShareLock on any tables, or whether any new indexes have been created, but we’re checking whether there was a create index without concurrently. This would fail to match statements that implicitly create an index, such as adding a unique constraint.\nWe’re also “guessing” whether a statement takes AccessExclusiveLock for our warnings about running more statements after taking dangerous locks. But on the whole, this approach has worked out quite well, I would say. Here’s an example of some test cases that pass now:\n#[test] fn test_locktimeout_alter_table_with_timeout() { let report = anon_lint(\"set lock_timeout = '2s'; \\ create index books_title_idx on books(title);\") .unwrap(); assert!(!matched_lint_rule(\u0026report, rules::LOCKTIMEOUT_WARNING.id())); } #[test] fn test_create_index_concurrently_is_not_dangerous_lock() { let report = anon_lint(\"create index concurrently \\ books_title_idx on books(title);\").unwrap(); assert!(!matched_lint_rule(\u0026report, rules::LOCKTIMEOUT_WARNING.id())); } #[test] fn test_create_index_on_existing_table() { let report = anon_lint(\"create index books_title_idx \\ on books(title);\").unwrap(); assert!(matched_lint_rule( \u0026report, rules::CREATE_INDEX_NONCONCURRENTLY.id() )); } I have already added specific lints for things like implicit index creation for instances that I am aware of, and I think the lints already pretty robust in total.\nResults There’s a lot of code, but I think it’s been worth it. For what it’s worth, a lot of the new code is pretty simple matching against the two different AST representations and I think writing the rules is easy enough. I know that there are false positives on the lints and that they won’t pick up all the things eugene trace can pick up, but I think they’re useful already. Aside from the table rewrite detection in eugene trace, we can pick up all the other dangerous patterns sometimes.\nSince I know the lints can trigger false positives, I’ve had to make sure that the user can disable lints and to make sure that they can be enabled/disable on a per-statement basis. So you can either eugene lint --ignore E3 if you really disagree with the rule that says you shouldn’t add json columns, or you can add a comment to a single statement where there’s an exception to the rule, like this:\n-- eugene: ignore E3 alter table books add column data json; Since this feature seems useful, I’ve added it to eugene trace as well and made both commands fail if any lints are triggered (which you can opt out of with -a or --accept-failures).\nAll the examples in the examples folder now contain both a linted and a traced variant, to show the difference.\n","wordCount":"1475","inLanguage":"en","datePublished":"2024-05-16T00:00:00Z","dateModified":"2024-05-18T00:00:00Z","author":{"@type":"Person","name":"Robin Kåveland"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kaveland.no/posts/2024-05-16-linting-postgres-migration-scripts/"},"publisher":{"@type":"Organization","name":"Robin's blog","logo":{"@type":"ImageObject","url":"https://kaveland.no/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kaveland.no/ accesskey=h title="Robin's blog (Alt + H)">Robin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kaveland.no/about/ title=about><span>about</span></a></li><li><a href=https://kaveland.no/projects/ title=projects><span>projects</span></a></li><li><a href=https://kaveland.no/eugene/ title=eugene><span>eugene</span></a></li><li><a href=https://kaveland.no/thumper/ title=thumper><span>thumper</span></a></li><li><a href=https://kaveland.no/tags/ title=tags><span>tags</span></a></li><li><a href=https://kaveland.no/archives/ title=archives><span>archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kaveland.no/>Home</a>&nbsp;»&nbsp;<a href=https://kaveland.no/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Linting postgres migration scripts</h1><div class=post-meta><span title='2024-05-16 00:00:00 +0000 UTC'>May 16, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1475 words&nbsp;·&nbsp;Robin Kåveland&nbsp;|&nbsp;<a href=https://github.com/kaaveland/kaaveland.github.io/content/posts/2024-05-16-linting-postgres-migration-scripts.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#linting-sql-with-pq_>Linting SQL with <a href=https://github.com/pganalyze/pg_query.rs>pq_query.rs</a></a></li><li><a href=#navigating-pg_querynoderef>Navigating <code>pg_query::NodeRef</code></a></li><li><a href=#writing-rules>Writing rules</a></li><li><a href=#results>Results</a></li></ul></nav></div></details></div><div class=post-content><p>I have been working quite a bit on picking up dangerous migration patterns in
migration scripts over at the <a href=https://github.com/kaaveland/eugene>eugene repository</a>
lately. A major feature I&rsquo;ve added is syntax tree analysis, so that we can pick
up some patterns without having to run the SQL scripts. This isn&rsquo;t quite as precise
as running the scripts, but it&rsquo;s a lot faster and can catch quite a few
common mistakes. So let&rsquo;s take a look at how it works!</p><h2 id=linting-sql-with-pq_>Linting SQL with <a href=https://github.com/pganalyze/pg_query.rs>pq_query.rs</a><a hidden class=anchor aria-hidden=true href=#linting-sql-with-pq_>#</a></h2><p>One of the fun things about writing <code>eugene</code> in Rust, is that I get to use
native libraries. This is a pretty useful capability to have, as it turns
out that SQL is a really huge language that is painful to parse, and there
is an excellent open source parser for it in Postgres itself.</p><p>pg_query.rs is a Rust wrapper around the Postgres parser, and it&rsquo;s been
really easy to start using it, by just running <code>cargo add pg_query</code>.</p><p>Note that this doesn&rsquo;t mean it&rsquo;s easy to use! Or rather, it&rsquo;s not that hard
to use, but even though someone else wrote the parser, the language itself
is still huge and complex. But it&rsquo;s done now, <code>eugene lint</code> can parse SQL
and give some useful hints:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>eugene lint -f json examples/alter_column_unique.sql
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;examples/alter_column_unique.sql&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;lints&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;statement_number&#34;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;sql&#34;</span><span class=p>:</span> <span class=s2>&#34;alter table books add constraint unique_title unique(title)&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;lints&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;E7&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;Creating a new unique constraint&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;condition&#34;</span><span class=p>:</span> <span class=s2>&#34;Found a new unique constraint and a new index&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;effect&#34;</span><span class=p>:</span> <span class=s2>&#34;This blocks all writes to the table while the index is being created and validated&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;workaround&#34;</span><span class=p>:</span> <span class=s2>&#34;`CREATE UNIQUE INDEX CONCURRENTLY`, then add the constraint using the index&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;help&#34;</span><span class=p>:</span> <span class=s2>&#34;New constraint unique_title creates implicit index on `public.books`, blocking writes until index is created and validated&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;id&#34;</span><span class=p>:</span> <span class=s2>&#34;E9&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;Taking dangerous lock without timeout&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;condition&#34;</span><span class=p>:</span> <span class=s2>&#34;A lock that would block many common operations was taken without a timeout&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;effect&#34;</span><span class=p>:</span> <span class=s2>&#34;This can block all other operations on the table indefinitely if any other transaction holds a conflicting lock while `idle in transaction` or `active`&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;workaround&#34;</span><span class=p>:</span> <span class=s2>&#34;Run `SET LOCAL lock_timeout = &#39;2s&#39;;` before the statement and retry the migration if necessary&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=nt>&#34;help&#34;</span><span class=p>:</span> <span class=s2>&#34;Statement takes lock on `public.books`, but does not set a lock timeout&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Splitting a SQL script into statements is super simple:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// Separate SQL script into statements
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>sql_statements</span><span class=p>(</span><span class=n>sql</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=nb>Vec</span><span class=o>&lt;&amp;</span><span class=kt>str</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Ok</span><span class=p>(</span><span class=n>pg_query</span>::<span class=n>split_with_parser</span><span class=p>(</span><span class=n>sql</span><span class=p>)</span><span class=o>?</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>into_iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>s</span><span class=o>|</span><span class=w> </span><span class=n>s</span><span class=p>.</span><span class=n>trim</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>collect</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Parsing a statement is also pretty simple, you just call <code>pg_query::parse</code>. The hard part
starts once you have gotten the syntax tree.</p><h2 id=navigating-pg_querynoderef>Navigating <code>pg_query::NodeRef</code><a hidden class=anchor aria-hidden=true href=#navigating-pg_querynoderef>#</a></h2><p>At the start, I tried to work with the enum <code>pg_query::NodeRef</code>. This uses a nice pattern I hadn&rsquo;t seen before,
here&rsquo;s an excerpt:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Debug, Copy, Clone)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>NodeRef</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Alias</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>protobuf</span>::<span class=n>Alias</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>RangeVar</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>protobuf</span>::<span class=n>RangeVar</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TableFunc</span><span class=p>(</span><span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>protobuf</span>::<span class=n>TableFunc</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Each of the variants of <code>NodeRef</code> contains a reference to a protobuf struct
(generated by <a href=https://docs.rs/prost/latest/prost/>prost</a>) that contains the actual data.</p><p>This is much nicer to work with than putting the actual data in enum variants, because it means
you can type a function to accept &ldquo;the variant&rdquo;, so it&rsquo;s clear what kind of data it expects,
and you avoid having to match on the enum in more than one place. This kind of makes it feel like a
scala <code>sealed trait</code> with <code>case class</code>es in terms of capabilities, which is nice. The disadvantage
is that there&rsquo;s an extra layer of unpacking to do in matches, in order to get the data, you&rsquo;d have
to do something like this to bind the <code>aliasname</code> field of an <code>Alias</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>example</span><span class=p>(</span><span class=n>stmt</span>: <span class=nc>pg_query</span>::<span class=n>NodeRef</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>stmt</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>NodeRef</span>::<span class=n>Alias</span><span class=p>(</span><span class=n>pg_query</span>::<span class=n>protobuf</span>::<span class=n>Alias</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>aliasname</span><span class=p>,</span><span class=w> </span><span class=o>..</span><span class=w> </span><span class=p>})</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w> </span><span class=c1>// Do something with `aliasname`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>NodeRef</code> and its sibling <code>Node</code> turn up in a lot of places in the protobuf structs, and are
a bit difficult to work with, with all the borrowing, referencing and this extra layer.</p><p>For this reason I decided to translate the part of the grammar I wanted to analyze into
something that was easier to work with, which I named <code>StatementSummary</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Debug, Clone, PartialEq, Eq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>StatementSummary</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Ignored</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>LockTimeout</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>CreateTable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>CreateTableAs</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>CreateIndex</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>AlterTable</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=p>},</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>describe</span><span class=p>(</span><span class=n>statement</span>: <span class=kp>&amp;</span><span class=nc>pg_query</span>::<span class=n>NodeRef</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>anyhow</span>::<span class=nb>Result</span><span class=o>&lt;</span><span class=n>StatementSummary</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>statement</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pg_query</span>::<span class=n>NodeRef</span>::<span class=n>VariableSetStmt</span><span class=p>(</span><span class=n>child</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>set_statement</span><span class=p>(</span><span class=n>child</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pg_query</span>::<span class=n>NodeRef</span>::<span class=n>CreateStmt</span><span class=p>(</span><span class=n>child</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>create_table</span><span class=p>(</span><span class=n>child</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pg_query</span>::<span class=n>NodeRef</span>::<span class=n>CreateTableAsStmt</span><span class=p>(</span><span class=n>child</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>create_table_as</span><span class=p>(</span><span class=n>child</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pg_query</span>::<span class=n>NodeRef</span>::<span class=n>IndexStmt</span><span class=p>(</span><span class=n>child</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>create_index</span><span class=p>(</span><span class=n>child</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pg_query</span>::<span class=n>NodeRef</span>::<span class=n>AlterTableStmt</span><span class=p>(</span><span class=n>child</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>alter_table</span><span class=p>(</span><span class=n>child</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>StatementSummary</span>::<span class=n>Ignored</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Note that because of the way the protobuf structs are typed, we&rsquo;re being forced to return
<code>Result</code> instead of <code>StatementSummary</code> because something like <code>NodeRef::CreateStmt</code> contains
<code>Vec&lt;Node></code> in its <code>.table_elt</code> attribute, instead of a more narrow type, so there is no
guarantee in the types that a table element isn&rsquo;t something like a <code>CreateMaterializedViewStmt</code>,
even though we know that the parser would never do that to us.</p><p>Once the translation is done, we have something that&rsquo;s pretty easy to lint against, but it is
still context free. We can&rsquo;t know if a <code>CREATE INDEX</code> statement is dangerous without knowing
whether the table it&rsquo;s created on is visible to other transactions or not. For that reason,
we also need to keep track of some sort of context, or result, of the transaction so far.</p><p>I named this concept a <code>TransactionState</code> and it looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[derive(Debug, Default, Eq, PartialEq)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>TransactionState</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>locktimeout</span>: <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>created_objects</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=p>(</span><span class=nb>String</span><span class=p>,</span><span class=w> </span><span class=nb>String</span><span class=p>)</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>altered_tables</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=p>(</span><span class=nb>String</span><span class=p>,</span><span class=w> </span><span class=nb>String</span><span class=p>)</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>has_access_exclusive</span>: <span class=kt>bool</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Copy, Clone)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>LintContext</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>ctx</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=nc>TransactionState</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=p>(</span><span class=k>crate</span><span class=p>)</span><span class=w> </span><span class=n>statement</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span> <span class=nc>StatementSummary</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>When bundled together with the <code>StatementSummary</code>, we can start to write some useful rules.</p><h2 id=writing-rules>Writing rules<a hidden class=anchor aria-hidden=true href=#writing-rules>#</a></h2><p>Initially, I wanted to aim for feature parity with the <code>eugene trace</code> command. This is
pretty difficult, because the <code>eugene trace</code> command actually runs the SQL scripts, and
can inspect their effects, whereas we&rsquo;re going to be working with a static analysis only.
But once I started writing rules, I realized that we may be able to implement most rules
that <code>eugene trace</code> has, it&rsquo;s just going to be less precise.</p><p>For example, here&rsquo;s the check for <code>create index</code> without <code>concurrently</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>fn</span> <span class=nf>create_index_nonconcurrently</span><span class=p>(</span><span class=n>stmt</span>: <span class=nc>LintContext</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Option</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>match</span><span class=w> </span><span class=n>stmt</span><span class=p>.</span><span class=n>statement</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>StatementSummary</span>::<span class=n>CreateIndex</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>schema</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>idxname</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>target</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>concurrently</span>: <span class=nc>false</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=o>..</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>stmt</span><span class=p>.</span><span class=n>is_visible</span><span class=p>(</span><span class=n>schema</span><span class=p>,</span><span class=w> </span><span class=n>target</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>schema</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>schema</span><span class=p>.</span><span class=n>is_empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=s>&#34;public&#34;</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>schema</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Some</span><span class=p>(</span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;Statement takes `ShareLock` on `</span><span class=si>{schema}</span><span class=s>.</span><span class=si>{target}</span><span class=s>`, blocking </span><span class=se>\</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>             writes while creating index `</span><span class=si>{schema}</span><span class=s>.</span><span class=si>{idxname}</span><span class=s>`&#34;</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=nb>None</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p><code>eugene trace</code> gets to just check if the transaction holds <code>ShareLock</code> on any tables, or whether
any new indexes have been created, but we&rsquo;re checking whether there was a <code>create index</code> without
<code>concurrently</code>. This would fail to match statements that <em>implicitly</em> create an index, such as
adding a <code>unique</code> constraint.</p><p>We&rsquo;re also &ldquo;guessing&rdquo; whether a statement takes <code>AccessExclusiveLock</code> for our warnings about
running more statements after taking dangerous locks. But on the whole, this approach has worked
out quite well, I would say. Here&rsquo;s an example of some test cases that pass now:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[test]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>test_locktimeout_alter_table_with_timeout</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>report</span><span class=w> </span><span class=o>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>anon_lint</span><span class=p>(</span><span class=s>&#34;set lock_timeout = &#39;2s&#39;; </span><span class=se>\</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>        create index books_title_idx on books(title);&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert!</span><span class=p>(</span><span class=o>!</span><span class=n>matched_lint_rule</span><span class=p>(</span><span class=o>&amp;</span><span class=n>report</span><span class=p>,</span><span class=w> </span><span class=n>rules</span>::<span class=no>LOCKTIMEOUT_WARNING</span><span class=p>.</span><span class=n>id</span><span class=p>()));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[test]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>test_create_index_concurrently_is_not_dangerous_lock</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>report</span><span class=w> </span><span class=o>=</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>anon_lint</span><span class=p>(</span><span class=s>&#34;create index concurrently </span><span class=se>\</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>         books_title_idx on books(title);&#34;</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert!</span><span class=p>(</span><span class=o>!</span><span class=n>matched_lint_rule</span><span class=p>(</span><span class=o>&amp;</span><span class=n>report</span><span class=p>,</span><span class=w> </span><span class=n>rules</span>::<span class=no>LOCKTIMEOUT_WARNING</span><span class=p>.</span><span class=n>id</span><span class=p>()));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[test]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>test_create_index_on_existing_table</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>report</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>anon_lint</span><span class=p>(</span><span class=s>&#34;create index books_title_idx </span><span class=se>\</span><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>           on books(title);&#34;</span><span class=p>).</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>assert!</span><span class=p>(</span><span class=n>matched_lint_rule</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&amp;</span><span class=n>report</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>rules</span>::<span class=no>CREATE_INDEX_NONCONCURRENTLY</span><span class=p>.</span><span class=n>id</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>I have already added specific lints for things like implicit index creation for instances that
I am aware of, and I think the lints already pretty robust in total.</p><h2 id=results>Results<a hidden class=anchor aria-hidden=true href=#results>#</a></h2><p>There&rsquo;s a <em>lot</em> of code, but I think it&rsquo;s been worth it. For what it&rsquo;s worth, a lot of the new code
is pretty simple matching against the two different AST representations and I think writing the rules
is easy enough. I know that there are false positives on the lints and that they won&rsquo;t pick up all
the things <code>eugene trace</code> can pick up, but I think they&rsquo;re useful already. Aside from the table
rewrite detection in <code>eugene trace</code>, we can pick up <em>all</em> the other dangerous patterns <em>sometimes</em>.</p><p>Since I know the lints can trigger false positives, I&rsquo;ve had to make sure that the user can
disable lints and to make sure that they can be enabled/disable on a per-statement basis. So
you can either <code>eugene lint --ignore E3</code> if you <em>really</em> disagree with the rule that says you
shouldn&rsquo;t add <code>json</code> columns, or you can add a comment to a single statement where there&rsquo;s an
exception to the rule, like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- eugene: ignore E3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>alter</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>books</span><span class=w> </span><span class=k>add</span><span class=w> </span><span class=k>column</span><span class=w> </span><span class=k>data</span><span class=w> </span><span class=n>json</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>Since this feature seems useful, I&rsquo;ve added it to <code>eugene trace</code> as well and made both commands
fail if any lints are triggered (which you can opt out of with <code>-a</code> or <code>--accept-failures</code>).</p><p>All the examples in the <a href=https://github.com/kaaveland/eugene/tree/main/examples>examples</a>
folder now contain both a <code>linted</code> and a <code>traced</code> variant, to show the difference.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kaveland.no/tags/postgres/>Postgres</a></li><li><a href=https://kaveland.no/tags/rust/>Rust</a></li><li><a href=https://kaveland.no/tags/eugene/>Eugene</a></li></ul><nav class=paginav><a class=prev href=https://kaveland.no/posts/2024-05-18-moving-to-hugo/><span class=title>« Prev</span><br><span>Moving the blog to Hugo</span>
</a><a class=next href=https://kaveland.no/posts/2024-05-16-porting-from-cats-effects-to-zio/><span class=title>Next »</span><br><span>Porting an application from cats effects to ZIO</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Linting postgres migration scripts on x" href="https://x.com/intent/tweet/?text=Linting%20postgres%20migration%20scripts&amp;url=https%3a%2f%2fkaveland.no%2fposts%2f2024-05-16-linting-postgres-migration-scripts%2f&amp;hashtags=postgres%2crust%2ceugene"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linting postgres migration scripts on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fkaveland.no%2fposts%2f2024-05-16-linting-postgres-migration-scripts%2f&amp;title=Linting%20postgres%20migration%20scripts&amp;summary=Linting%20postgres%20migration%20scripts&amp;source=https%3a%2f%2fkaveland.no%2fposts%2f2024-05-16-linting-postgres-migration-scripts%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linting postgres migration scripts on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fkaveland.no%2fposts%2f2024-05-16-linting-postgres-migration-scripts%2f&title=Linting%20postgres%20migration%20scripts"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linting postgres migration scripts on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fkaveland.no%2fposts%2f2024-05-16-linting-postgres-migration-scripts%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linting postgres migration scripts on whatsapp" href="https://api.whatsapp.com/send?text=Linting%20postgres%20migration%20scripts%20-%20https%3a%2f%2fkaveland.no%2fposts%2f2024-05-16-linting-postgres-migration-scripts%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linting postgres migration scripts on telegram" href="https://telegram.me/share/url?text=Linting%20postgres%20migration%20scripts&amp;url=https%3a%2f%2fkaveland.no%2fposts%2f2024-05-16-linting-postgres-migration-scripts%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Linting postgres migration scripts on ycombinator" href="https://news.ycombinator.com/submitlink?t=Linting%20postgres%20migration%20scripts&u=https%3a%2f%2fkaveland.no%2fposts%2f2024-05-16-linting-postgres-migration-scripts%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://kaveland.no/>Robin's blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>